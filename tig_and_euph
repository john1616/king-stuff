# this program is mostly finished for human players only, but it may have bugs.  in
# the future i would like to implement computer players.  the program is being made
# for my own education and entertainment.  it is based on a board game called 
# "tigris and euphrates".  if you like the program, go buy the game!!

# it does not yet have any instructions or help.  the rules may be found online
# and the commands (though fairly obvious if you know the rules) may be easily 
# determined from the code.  

# (this code is for Python)

#					tigris and euphrates					#
#					draft number two						#



# TABLE OF CONTENTS:
# 1) notes
# 2) imports
# 3) states in the game - the location of each piece, players' hands, scores, 
#	 etc. this information would be enough to recreate a game at a given
#	 moment on a physical board. 
# 4) graphical representations - the board, as it is displayed in terminal or 
#	 whatever you're using
# 5) moves, rules and regulations
# 6) game structure - gameplay organized into a cohesive flow, i.e. a game
# T) test running



##1## notes

# sections are referred to as #1# for section 1, etc.
# terminal window should be set to at least 100x50.
# i generally use q (or (x,y)) to describe "grid" coordinates -- this is the 
# board grid as concerns gameplay.  graphics are determined by variables 
# stored in bg ("board graphics"; it is a dict of 1171 strings), and are 
# described in functions by v.  the player will see the board labled with
# letters for the horizontal axis and numbers for the vertical axis, which
# is called the coor(dinate).  

###

##2## imports:

from random import random

def num_to_alpha(x):
	if x == 1: return "A"        
	elif x == 2: return "B"
	elif x == 3: return "C"
	elif x == 4: return "D"
	elif x == 5: return "E"
	elif x == 6: return "F"
	elif x == 7: return "G"
	elif x == 8: return "H"
	elif x == 9: return "I"
	elif x == 10: return "J"
	elif x == 11: return "K"
	elif x == 12: return "L"
	elif x == 13: return "M"
	elif x == 14: return "N"
	elif x == 15: return "O"
	elif x == 16: return "P"
	elif x == 17: return "Q"
	elif x == 18: return "R"
	elif x == 19: return "S"
	elif x == 20: return "T"
	elif x == 21: return "U"
	elif x == 22: return "V"
	elif x == 23: return "W"
	elif x == 24: return "X"
	elif x == 25: return "Y"
	elif x == 26: return "Z"
	else:
		print "ERROR #001"

def alpha_to_num(letter):
	if letter.upper() == "A": x = 1
	elif letter.upper() == "B": x = 2
	elif letter.upper() == "C": x = 3
	elif letter.upper() == "D": x = 4
	elif letter.upper() == "E": x = 5
	elif letter.upper() == "F": x = 6
	elif letter.upper() == "G": x = 7
	elif letter.upper() == "H": x = 8
	elif letter.upper() == "I": x = 9
	elif letter.upper() == "J": x = 10
	elif letter.upper() == "K": x = 11
	elif letter.upper() == "L": x = 12
	elif letter.upper() == "M": x = 13
	elif letter.upper() == "N": x = 14
	elif letter.upper() == "O": x = 15
	elif letter.upper() == "P": x = 16
	elif letter.upper() == "Q": x = 17
	elif letter.upper() == "R": x = 18
	elif letter.upper() == "S": x = 19
	elif letter.upper() == "T": x = 20
	elif letter.upper() == "U": x = 21
	elif letter.upper() == "V": x = 22
	elif letter.upper() == "W": x = 23
	elif letter.upper() == "X": x = 24
	elif letter.upper() == "Y": x = 25
	elif letter.upper() == "Z": x = 26
	else:
		print "ERROR #002"
	return x

def pick_ran(some_list):
# i should have made this function long ago! it's probably built in somewhere.
	return some_list[int(random() *len(some_list) )]


###

##3## states in the game

# there will be a number of lists/dicts/sets for keeping track of the elements
# of the game, some of are dependent on others (for example, a list of
# locations on the board and what pieces, if any, are on them).  there will
# be functions that update the dependent lists (which must be called before
# any of the dependent lists are used).
#
# game board:
# the board is 16 x 11.  it is marked (for the human player) as A to P on the
# horizontal axis and 1 to 11 on the vertical axis.  i will keep these
# coordinates in the program mechanics, but will use integers for A to P
# (i.e., 1 to 16).  thus, the grid of the game board (and what is on the grid)
# will be represented by a dict of 176 tuples, from (1,1) to (11,16).  the
# values of these tuples may one of the following strings (not written here
# with ""; remarks in parentheses are not included in the string):
#
#	empty			river
#	red (tile)		blue (tile)		black (tile)	green (tile)
#	rl1 (red leader of player 1)	al1 (black leader of player 1)
#	ul1 (blue leader of player 1)	gl1 (green leader of player 1)
#	rl2 ... 						... gl4
#	catastrophe			monument (NW/NE/SW/SE; of two colors)
#	red w treasure		monument w treasure
#
# in the original game, there are two rivers that run across the board.  here,
# that setup will be the default, but i will construct the program to allow
# for a way to make a custom river.  

def create_main_grid():         # creates a dict that has coordinates on the
	grid = {}                   # board as keys and strings as values, which
	for i in range(1,17):       # represent the pieces on the board.  
		for j in range(1,12):
			grid[(i,j)] = "empty"
	return grid

def grid_main_to_user(q):   	# translates a tuple coordinate on the board
	x, y = q					# to the corresponding string that would be
	coor = ""                   # used and understood by the human player
	coor += num_to_alpha(x)
	coor += str(y)
	return coor

def grid_user_to_main(coor):    		# translates a coordinate as a letter-
	if coor == "": 
		return False
	elif coor.lower() == "remove":
		return 0
	elif coor[0].lower() not in ['a','b','c','d','e','f','g','h', \
	'i','j','k','l','m','n','o','p']:   # number string to a tuple coordinate.
		return False					# returns False in case of an error
	elif coor[1:].isdigit() == False:
		return False
	elif int(coor[1:]) > 11 or int(coor[1:]) < 1:
		return False
	else:
		x = alpha_to_num(coor[0])
		y = int(coor[1:])
		return (x,y)

def define_default_river():		# simply returns the coordinates of the river
	river1 = [(1,4),(2,4),(3,4),(4,4),(4,3),(5,3),(5,2),(5,1), \
			(6,1),(7,1),(8,1),(9,1)]

	river2 = [(1,7),(2,7),(3,7),(4,7),(4,8),(5,8),(6,8),(7,8),(7,9), \
		(8,9),(9,9),(10,9),(11,9),(12,9),(13,9),(13,8),(13,7),(14,7),(15,7), \
		(15,6),(15,5),(16,5),(16,4),(15,4),(14,4),(14,3),(13,3),(13,2),(13,1)]

	return (river1,river2)

def define_default_treasure():	# returns coordinates of the treasures
	return [(2,2),(6,3),(11,1),(16,2),(14,5),(9,7),(2,8),(6,10),(11,11),(15,9)]

def get_leader_location():
	leader_loc = {"rl1":0,"ul1":0,"al1":0,"gl1":0,"rl2":0,"ul2":0,"al2":0, \
	"gl2":0,"rl3":0,"ul3":0,"al3":0,"gl3":0,"rl4":0,"ul4":0,"al4":0,"gl4":0}
	for q in grid:
		if grid[q] in leaders:
			leader_loc[grid[q]] = q
	return leader_loc

def randomly_assign_player_symbols():
	symbols = {1:0,2:0,3:0,4:0}
	available_symbols = ["o","x","+","*"]
	r1 = random()
	if r1 < .25:
		symbols[1] = available_symbols[0]
		available_symbols.remove(symbols[1])
	elif r1 < .5:
		symbols[1] = available_symbols[1]
		available_symbols.remove(symbols[1])
	elif r1 < .75:
		symbols[1] = available_symbols[2]
		available_symbols.remove(symbols[1])
	else:
		symbols[1] = available_symbols[3]
		available_symbols.remove(symbols[1])
	r2 = random()
	if r2 < .3333:
		symbols[2] = available_symbols[0]
		available_symbols.remove(symbols[2])
	elif r2 < .6667:
		symbols[2] = available_symbols[1]
		available_symbols.remove(symbols[2])
	else:
		symbols[2] = available_symbols[2]
		available_symbols.remove(symbols[2])
	r3 = random()
	if r3 < .5:
		symbols[3] = available_symbols[0]
		available_symbols.remove(symbols[3])
	else:
		symbols[3] = available_symbols[1]
	symbols[4] = available_symbols[0]
	return symbols

def prompt_for_num_of_hum_players():
	global human_or_comp
	human_or_comp = {1:"human",2:"human",3:"human",4:"human"}
	num = False
	while num == False:
		num = raw_input('How many players will be played by humans?   ')
		if num not in ['1','2','3','4']:
			num = False
			print "Type a number from 1 to 4."
		else:
			num = int(num)
	available_players = [1,2,3,4]
	for i in range(4-num):
		p = available_players[int(random() * len(available_players))]
		human_or_comp[p] = "comp"
		available_players.remove(p)

	# this part subject to change
	for p in human_or_comp:
		if human_or_comp[p] == "comp":
			human_or_comp[p] = "joe_youngling"




def reset_variables_and_board():
	# here's where there would be a control on which river / treasure to pick
	# (instead of using the defaults found in the original game)


	global leaders
	global symbols
	global grid
	global bg
	global scores
	global bag
	global hands
	global catastrophes
	global kingdoms
	global monuments
	global clist
	global standard_commands
	global feed
	global pertinent_feed
	global log
	

	
	leaders = ["rl1","rl2","rl3","rl4","ul1","ul2","ul3","ul4", \
			   "al1","al2","al3","al4","gl1","gl2","gl3","gl4"]

	symbols = randomly_assign_player_symbols()
	grid = create_main_grid()
	bg = reset_board_graphics()

	rivers = define_default_river()
	for q in [q for river in rivers for q in river]:
		grid[q] = "river"
	set_river_graphics(rivers,bg) # defined below, in #4#

	treasure = define_default_treasure()
	for q in treasure: 
		place(q, "treasure") # this is a key function, found in #5#

	scores = {1:[0,0,0,0,0],2:[0,0,0,0,0],3:[0,0,0,0,0],4:[0,0,0,0,0]}
	bag = [47,36,30,30] # red, blue, black, green tiles remaining
	hands = {1:[0,0,0,0], 2:[0,0,0,0], 3:[0,0,0,0], \
			4:[0,0,0,0]} # these will be filled in #5#
	catastrophes = {1:2,2:2,3:2,4:2}
	kingdoms = {}
	monuments = ["red - blue", "red - black", "red - green", "blue - black", \
					"blue - green", "black - green"]
	clist = ["red","blue","black","green"]
	standard_commands = {"leaders": show_leaders, "scores": print_scores, \
				"hand": display_hand, "feed": display_feed}
	feed = ["   FEED   ", ""]
	pertinent_feed = [0]
	# for the use of the AI:
	log = [] 

###

##4## graphical representations

# i am using a lot of variables, many of which will not get used (very much).  
# the game board is 16 x 11, but each tile is going to consist of a 5 x 3
# square (including the lower border but not the sides).  each of the three
# lines of the interior of a tile will have a separate variable (that is, a
# value in a dict), and each piece of the side borders will also have a
# variable (which will usually just be a vertical bar, '|').  almost all of
# the graphical variation will occur on the middle variable.  each spot on the
# board will be assigned a number:

#	 ___________	0( 1 )2( 3 )4(... 		the top line will have only 33
#	|     |     |	33(34)35(36)37...		variables, but all others will
#	| *** |   r r	67(68)69(70)71...		have 34.  of the variables shown
#	|_____|__r__|	|_____|__r__|			to the left, 68 and 70 are the
#	|     |  r  |	|     |  r  |			only ones that would be affected
#	|     | *** |	|     | *** |			by the majority of in-game play.
#	|_____|__r__|	|_____|__r__|	
#
#


def reset_board_graphics():
	bg = {}
	for v in range(1171):
		bg[v] = "x"
	bg[0] = " "
	bg[32] = "   "
	for v in range(1,32,2):
		bg[v] = "_____"
	for v in range(2,31,2):
		bg[v] = "_"
	for v in range(33,1155,2):
		bg[v] = "|"
	for v in range(66,1155,34):
		bg[v] = "   "
	for v in range(100,1155,102):
		bg[v] = " %s" % ( (v-100)/102 + 1 )
	for row in range(1,34,3):
		for v in range(row*34,row*34+31,2):
			bg[v] = "     "
	for row in range(2,34,3):
		for v in range(row*34,row*34+31,2):
			bg[v] = "     "
	for row in range(3,34,3):
		for v in range(row*34,row*34+31,2):
			bg[v] = "_____"
	for v in range(1155,1171):
		bg[v] = "   %s  " % (num_to_alpha(v-1154))
	return bg


def set_river_graphics(rivers,bg):
	for river in rivers:
		for q in [river[0]]: #first endpoint
			if q[0] == 1:
				bg[q_to_v(q)-1] = "r"
				if river[1][0] == 1:
					bg[q_to_v(q)] = " r   "
				else:
					bg[q_to_v(q)] = " r r "
			elif q[0] == 16:
				bg[q_to_v(q)+1] = "r"
				if river[1][0] == 16:
					bg[q_to_v(q)] = "   r "
				else:
					bg[q_to_v(q)] = " r r "
			elif q[1] == 1:
				bg[q_to_v(q)-34] = "  r  "
				bg[q_to_v(q)-67] = "__r__"
				if river[1][1] == 2:
					bg[q_to_v(q)] = "  r  "
				elif river[1][0] == q[0] + 1:
					bg[q_to_v(q)] = "   r "
				elif river[1][0] == q[0] - 1:
					bg[q_to_v(q)] = " r   "
			elif q[1] == 11:
				bg[q_to_v(q)+34] = "___r_"
				if river[1][1] == 10:
					bg[q_to_v(q)] = "  r  "
				elif river[1][0] == q[0] + 1:
					bg[q_to_v(q)] = "   r "
				elif river[1][0] == q[0] - 1:
					bg[q_to_v(q)] = " r   "
		for q in [river[-1]]: # 2nd endpoint
			if q[0] == 1:
				bg[q_to_v(q)-1] = "r"
				if river[-2][0] == 1:
					bg[q_to_v(q)] = " r   "
				else:
					bg[q_to_v(q)] = " r r "
			elif q[0] == 16:
				bg[q_to_v(q)+1] = "r"
				if river[-2][0] == 16:
					bg[q_to_v(q)] = "   r "
				else:
					bg[q_to_v(q)] = " r r "
			elif q[1] == 1:
				bg[q_to_v(q)-34] = "  r  "
				bg[q_to_v(q)-67] = "__r__"
				if river[-2][1] == 2:
					bg[q_to_v(q)] = "  r  "
				elif river[-2][0] == q[0] + 1:
					bg[q_to_v(q)] = "   r "
				elif river[-2][0] == q[0] - 1:
					bg[q_to_v(q)] = " r   "
			elif q[1] == 11:
				bg[q_to_v(q)+34] = "___r_"
				if river[-2][1] == 10:
					bg[q_to_v(q)] = "  r  "
				elif river[-2][0] == q[0] + 1:
					bg[q_to_v(q)] = "   r "
				elif river[-2][0] == q[0] - 1:
					bg[q_to_v(q)] = " r   "
		for bo in range(len(river)-1): # border btwn middle river sections
			if river[bo][0] + 1 == river[bo+1][0]:
				bg[q_to_v(river[bo])+1] = "r"
			elif river[bo][0] - 1 == river[bo+1][0]:
				bg[q_to_v(river[bo])-1] = "r"
			elif river[bo][1] + 1 == river[bo+1][1]:
				bg[q_to_v(river[bo])+34] = "__r__"
				bg[q_to_v(river[bo])+68] = "  r  "
			elif river[bo][1] - 1 == river[bo+1][1]:
				bg[q_to_v(river[bo])-34] = "  r  "
				bg[q_to_v(river[bo])-68] = "__r__"
		for m in range(1,len(river)-1): # main v for middle river sections
			if river[m][0] + 1 == river[m+1][0] or \
			river[m][0] + 1 == river[m-1][0]:
				if river[m][0] - 1 == river[m+1][0] or \
				river[m][0] - 1 == river[m-1][0]:
					bg[q_to_v(river[m])] = " r r "
				else:
					bg[q_to_v(river[m])] = "   r "
			else:
				if river[m][0] - 1 == river[m+1][0] or \
				river[m][0] - 1 == river[m-1][0]:
					bg[q_to_v(river[m])] = " r   "
				else:
					bg[q_to_v(river[m])] = "  r  "


def q_to_v(q):
	x, y = q
	v = 2 * x + y * 102 - 36
	return v

def board_graphics_update(q, piece): # will have to change this if
	v = q_to_v(q)                    # forks in the river are allowed
	if piece == "river":
		river_graphics_update(v)
	elif piece == "empty": 
		bg[v-34] = "     "
		bg[v] = "     "
		bg[v+34] = "_____"
	elif piece == "red":
#		bg[v-34] = ".   ."
		bg[v-34] = "     "
		bg[v] = " tem "
#		bg[v+34] = ".___."
	elif piece == "blue":
		bg[v] = " frm "
#		if bg[v-34][2] == "r":
#			bg[v-34] = ". r ."
#		else:
#			bg[v-34] = ".   ."
#		if bg[v+34][2] == "r":
#			bg[v+34] = "._r_."
#		else:
#			bg[v+34] = ".___."

#	elif piece == "blue" and 1 ==2:		# debatable what the best
#		if bg[v-34][2] == "r":			# graphic for farms (on
#			N = True 					# rivers) is.  sticking
#			bg[v-34] = ". r ."			# with a simple option here
#		else:
#			N = False
#			bg[v-34] = ".   ."
#		if bg[v+34][2] == "r":
#			S = True
#			bg[v+34] = "._r_."
#		else:
#			S = False
#			bg[v+34] = ".___."
#		if bg[v-1] == "r":
#			if N or S:
#				bg[v] = " frm "
#			else:
#				bg[v] = " frm "
#		elif bg[v+1] == "r":
#			bg[v] = " frm "
#		bg[v-34] = ". r ."
#		bg[v+34] = "._r_."

	elif piece == "black":
#		bg[v-34] = ".   ."
		bg[v] = " set "
#		bg[v+34] = ".___."
	elif piece == "green":
#		bg[v-34] = ".   ."
		bg[v] = " mkt "
#		bg[v+34] = ".___."
	elif piece in leaders:
		if piece[0] == "r":
			bg[v] = " PST "
		elif piece[0] == "u":
			bg[v] = " FMR "
		elif piece[0] == "a":
			bg[v] = " KNG "
		elif piece[0] == "g":
			bg[v] = " TDR "
		p = int(piece[2])
		bg[v-34] = symbols[p] + " " + piece[2] + " " + symbols[p]
		bg[v+34] = symbols[p] + "_" + piece[2] + "_" + symbols[p]
	elif piece == "treasure":
		bg[v] = " tem "
		bg[v-34] = " $$$ "
	elif piece == "catastrophe":
		bg[v-34] = " X X "
		bg[v] = "X 0 X"
		bg[v+34] = "_X_X_"


def river_graphics_update(v):
	if bg[v+1] == "r":
		if bg[v-1] == "r":
			bg[v] = " r r "
		else:
			bg[v] = "   r "
	else:
		if bg[v-1] == "r":
			bg[v] = " r   "
		else:
			bg[v] = "  r  "
	if bg[v-34][2] == "r":
		bg[v-34] = "  r  "
	else: 
		bg[v-34] = "     "
	if bg[v+34][2] == "r":
		bg[v+34] = "__r__"
	else: 
		bg[v+34] = "_____"

def paint_monument(NWq, color1, color2, treasure_in_mon):
	bg[q_to_v(NWq)-34] = " +---"
	bg[q_to_v(NWq)-33] = "-"
	bg[q_to_v(NWq)-32] = "---+ "
	if color1 == "red":
		bg[q_to_v(NWq)] = " |  R"
	elif color1 == "green":
		bg[q_to_v(NWq)] = " | GR"
	else:
		bg[q_to_v(NWq)] = " | BL"
	if color1 == "black":
		bg[q_to_v(NWq)+1] = "A"
	elif color1 == "blue":
		bg[q_to_v(NWq)+1] = "U"
	else:
		bg[q_to_v(NWq)+1] = "E"
	if color1 == "red":
		bg[q_to_v(NWq)+2] = "D  | "
	elif color1 == "green":
		bg[q_to_v(NWq)+2] = "EN | "
	elif color1 == "black":
		bg[q_to_v(NWq)+2] = "CK | "
	else:
		bg[q_to_v(NWq)+2] = "E  | "
	if treasure_in_mon == True:
		bg[q_to_v(NWq)+34] = " |  $"
		bg[q_to_v(NWq)+35] = "$"
		bg[q_to_v(NWq)+36] = "$  | "
	else:
		bg[q_to_v(NWq)+34] = " |   "
		bg[q_to_v(NWq)+35] = " "
		bg[q_to_v(NWq)+36] = "   | "
	if color2 == "red":
		bg[q_to_v(NWq)+68] = " |  R"
	elif color2 == "green":
		bg[q_to_v(NWq)+68] = " | GR"
	elif color2 == "blue":
		bg[q_to_v(NWq)+68] = " |  B"
	else:
		bg[q_to_v(NWq)+68] = " | BL"
	if color2 == "black":
		bg[q_to_v(NWq)+69] = "A"
	elif color2 == "blue":
		bg[q_to_v(NWq)+69] = "L"
	else:
		bg[q_to_v(NWq)+69] = "E"
	if color2 == "red":
		bg[q_to_v(NWq)+70] = "D  | "
	elif color2 == "green":
		bg[q_to_v(NWq)+70] = "EN | "
	elif color2 == "black":
		bg[q_to_v(NWq)+70] = "CK | "
	else:
		bg[q_to_v(NWq)+70] = "UE | "
	bg[q_to_v(NWq)+102] = " +---"
	bg[q_to_v(NWq)+103] = "-"
	bg[q_to_v(NWq)+104] = "---+ "

def beg_conflict_graphic(q):
	vtop = bg[q_to_v(q)-34]
	vmid = bg[q_to_v(q)]
	vbot = bg[q_to_v(q)+34]
	stored_graphics = (vtop, vmid, vbot)
	bg[q_to_v(q)-34] = "\ | /"
	bg[q_to_v(q)] = "- * -"
	bg[q_to_v(q)+34] = "/_|_\\"
	return stored_graphics

def end_conflict_graphic(q, stored_graphics): 
	vtop, vmid, vbot = stored_graphics
	bg[q_to_v(q)-34] = vtop
	bg[q_to_v(q)] = vmid
	bg[q_to_v(q)+34] = vbot

def print_board():
	print """

	"""
	rows = [""]*35	
	for v in range(33):
		rows[0] += bg[v]
	for row in range(1,34):
		for v in range(row*34-1,row*34+33):
			rows[row] += bg[v]
	for v in range(1155,1171):
		rows[34] += bg[v]
	for row in rows:
		print row
	return rows

def update_feed(new_line, pertinent):
	feed.append(new_line)
	if pertinent == True:
		pertinent_feed[0] = len(feed)
		pertinent_feed.append(new_line)

	#display:
	print_board()
	print ""
	for line in pertinent_feed:
		if type(line) == int: # i.e., first line of pert feed
			feed_start = max(line, len(feed) - 13 + len(pertinent_feed))
		else:
			print line
	if len(feed) > feed_start:
		for line in feed[feed_start:]:
			print line
	for line in range(16 - len(pertinent_feed) - len(feed) + feed_start):
		print ""

def feed_input(prompt, player):
	print_board()
	print ""
	for line in pertinent_feed:
		if type(line) == int: # i.e., first line of pert feed
			feed_start = max(line, len(feed) - 13 + len(pertinent_feed))
		else:
			print line
	if len(feed) > feed_start:
		for line in feed[feed_start:]:
			print line
	for line in range(15 - len(pertinent_feed) - len(feed) + feed_start):
		print ""
	inpt = raw_input(prompt)
	update_feed(prompt+inpt, False)
	while inpt in standard_commands.keys():
		standard_commands[inpt](player)
		inpt = feed_input(prompt, player) ############################################
	return inpt

def clear_pertinent_feed():
	global pertinent_feed
	pertinent_feed = [len(feed)]

def display_feed(p):
	for line in range(len(feed)):
		print line, feed[line]
	pause = raw_input("<end>")

###

##5## moves, rules and regulations

def initial_draw():
	for p in range(1,5):
		draw_tiles(p, 6)

def draw_tiles(p, num):
	for i in range(num):
		if sum(bag) == 0:
			bag_empty = True
			update_feed("", False)
			update_feed("The tiles have run out!", True)
		else:
			bag_empty = False
			r = random() * sum(bag)
			if r < bag[0]: 
				hands[p][0] += 1
				bag[0] -= 1
			elif r < bag[0]+bag[1]:
				hands[p][1] += 1
				bag[1] -= 1
			elif r < bag[0]+bag[1]+bag[2]:
				hands[p][2] += 1
				bag[2] -= 1
			else:
				hands[p][3] += 1
				bag[3] -= 1
	return bag_empty

def one_turn(p):
	update_feed("Player {0}'s turn.".format(p),True)
	bag_empty = False
	treas_gone, end_game_now = one_move(p, "first")
	if end_game_now == False:
		treas_gone, end_game_now = one_move(p, "second")
		score_monuments(p)
		for player in range(1,5):
			if sum(hands[player]) < 6:
				bag_empty = draw_tiles(player, 6 - sum(hands[player]))
	feed_input("End of player {0}'s turn.   ".format(p), p)
	clear_pertinent_feed()
	if bag_empty == True or treas_gone == True or end_game_now == True:
		end_game = True
	else:
		end_game = False
	return end_game

def print_scores(player):
	update_feed("", False)
	for p in range(1,5):
		update_feed("Player {0}'s scores: red: {1}, blue: {2}, black: {3}, \
green: {4}, treasures: {5}.  {6}".format(p, scores[p][0], \
		scores[p][1], scores[p][2], scores[p][3], scores[p][4], \
		symbols[p] if p==player else ""), False)

def one_move(player, f_or_s):
	p = player
	if human_or_comp[p] == "human":
		piece, dest = prompt_move(p, f_or_s)
	else:
		piece, dest = AI_mother(p, "game_move", (p, f_or_s))
	return make_move(dest, piece, player)

def display_hand(p):
	update_feed("Player {0}'s hand: {1} temple{2}, {3} farm{4}, {5} \
settlement{6} and {7} market{8}.  {9} catastrophe{10}.".format(p, \
	hands[p][0], "" if hands[p][0]==1 else "s", hands[p][1], "" if \
	hands[p][1]==1 else "s", hands[p][2], "" if hands[p][2]==1 else "s", \
	hands[p][3], "" if hands[p][3]==1 else "s", catastrophes[p], "" if \
	catastrophes[p]==1 else "s"), False)

def prompt_move(p, f_or_s):
	update_feed("Your {0} action: place a tile, move a leader, \
inflict a catastrophe or swap tiles.".format(f_or_s), False)
	display_hand(p)
	move_ok = False
	while move_ok == False:
		raw_piece = feed_input(" {0} ".format(symbols[p]), p)
		piece = fix_shorthand(raw_piece)
		if piece == "pass":
			return ("pass", None)
		elif piece == "swap":
			return ("swap", None)
		elif piece == False: # responds to invalid input
			update_feed("This is not a valid move.", False)
		elif (piece == "temple" and hands[p][0] == 0) or \
			(piece == "farm" and hands[p][1] == 0) or \
			(piece == "settlement" and hands[p][2] == 0) or \
			(piece == "market" and hands[p][3] == 0):
			update_feed("You do not have any tiles of type.  \
Choose another move.", False)
		elif piece == "catastrophe" and catastrophes[p] == 0:
			update_feed("You do not have any catastrophes left.  \
Choose another move.", False)
		else:
			update_feed("Where would you like to place the " + piece + "?", False)
			raw_dest = feed_input(" {0} ".format(symbols[p]), p)
			if raw_dest != "redo":
				dest = grid_user_to_main(raw_dest)
				move_ok = True
			else:
				update_feed("Place a tile, move a leader, \
inflict a catastrophe or swap tiles.", False)
	move_ok = False
	piece = translate_piece(piece, p)
	while move_ok == False:
		if dest == False:
			update_feed("This is not a valid coordinate on the grid.", False)
		else:
			valid = validmove(piece,dest)
			if valid != True:
				update_feed(valid, False)
			else:
				move_ok = True
		if move_ok == False:
			dest = grid_user_to_main(feed_input(" {0} ".format(symbols[p]), p))
	return (piece, dest)

def show_leaders(p):
	LL = get_leader_location()
	free_L = [fix_shorthand(L[:2]) for L in leaders if LL[L] == 0 and L[2] == str(p)]
	if free_L == []:
		update_feed("All leaders are on the board.", False)
	else:
		L_s = "Leaders not on board: "
		for L in free_L:
			L_s = L_s + L + ", "
	update_feed(L_s[:-2] + ".", False)

def fix_shorthand(raw_s):
	s = raw_s.lower()
	if s in ("red", "tem", "t", "temple"):
		return "temple"
	elif s in ("blue", "fa", "f", "farm"): 
		return "farm"
	elif s in ("black", "set", "s", "settlement"):
		return "settlement"
	elif s in ("green", "mar", "m", "market"):
		return "market"
	elif s in ("pri", "p", "rl", "priest"):
		return "priest"
	elif s in ("fr", "fmr", "ul", "farmer"): 
		return "farmer"
	elif s in ("kg", "k", "al", "kng", "king"): 
		return "king"
	elif s in ("tr", "t", "tdr", "gl", "trader"): 
		return "trader"
	elif s in ("c", "cat", "catastrophe"): 
		return "catastrophe"
	elif s in ("pass", "swap"):
		return s
	else:
		return False

def translate_piece(piece, player): # i used different terminology in the code
	if piece == "temple": return "red"
	if piece == "farm": return "blue"
	if piece == "settlement": return "black"
	if piece == "market": return "green"
	if piece == "priest": return "rl" + str(player)
	if piece == "farmer": return "ul" + str(player)
	if piece == "king": return "al" + str(player)
	if piece == "trader": return "gl" + str(player)
	if piece == "catastrophe": return "catastrophe"

def validmove(piece, dest):
	if piece not in leaders and dest == 0:
		return "Only leaders may be removed from the board."
	elif piece == "catastrophe":              # a valid move returns True;
		if grid[dest] == "catastrophe":		# else returns error message
			return "You may not place a catastrophe on another catastrophe."
		elif grid[dest] in leaders:
			return "You may not place a catastrophe on a leader."
		else:
			return True
	elif piece in clist:
		if grid[dest] not in ["empty","river"]:
			return "You must place a tile on an unoccupied space."
		elif grid[dest] == "river" and piece != "blue":
			return "Only farms may be placed on river spaces."
		elif grid[dest] != "river" and piece == "blue":
			return "Farms must be placed on river spaces."
		elif q_in_how_many_b(dest) > 2 :
			return "You may not join three or four kingdoms at one time."
		else:
			return True
	elif piece in leaders:
		if grid[dest] == piece:
			return "This leader is already at this location."
		elif grid[dest] not in ["empty","river"]:
			return "You must place a leader on an unoccupied space."
		elif grid[dest] == "river":
			return "You may not place a leader on a river space."
		elif "red" not in [grid[adj_q] for adj_q in adjacent_q(dest)] and \
			"treasure" not in [grid[adj_q] for adj_q in adjacent_q(dest)]:
			return "Leaders must be placed next to a temple."
		else:
			leader_loc = get_leader_location()
			if leader_loc[piece] != 0:
				save_q = grid[leader_loc[piece]]
				place(leader_loc[piece], "empty")
				assess_kingdoms()
				if q_in_how_many_b(dest) > 1:
					place(leader_loc[piece], piece)
					return "You may not join kingdoms with a leader."
				else: return True
			else: return True
	else:
		return "Enter a valid piece to move" # probably not necessary

def print_move(p, piece, dest):
	i_t = "Player " + str(p) #initial text is the same
	if dest != None:
		u_d = grid_main_to_user(dest)
	if piece == "pass":
		text =i_t+ " passes."
	elif piece == "swap":
		text =i_t+ " swaps tiles."
	elif piece == "catastrophe":
		text =i_t+ " places a catastrophe on " + u_d + "."
	elif piece in leaders:
		text =i_t+ " places {0} {1} on {2}.".format("her" if p%2==1 \
		else "his", fix_shorthand(piece[:2]), u_d)
	else:
		text =i_t+ " places a {0} on {1}.".format(fix_shorthand(piece), \
				u_d)
	update_feed(text, True)

def make_move(dest, piece, player):
	end_game_now = False
	print_move(player, piece, dest)
	if piece == "pass":
		pass
	elif piece == "swap":
		end_game_now = swap_tiles(player)
	elif piece == "catastrophe":
		place(dest, piece)
		check_temple_support()
		catastrophes[player] -= 1
	else:
		assess_kingdoms()
		bordering = q_in_how_many_b(dest)
		if piece in clist:
			hands[player][dict(zip(clist,[0,1,2,3]))[piece]] -= 1
			if bordering == 2:
				external_conflict(dest, player, piece)
			else:
				place(dest, piece)
				if bordering == 1:
					score_for_tile(dest, piece)
			check_monument_build(dest, player)
		elif piece in leaders:
			place(dest, piece)
			if bordering == 1:
				internal_conflict(dest, piece)
	treas_gone = check_treasure()
	return (treas_gone, end_game_now)

def place(q, piece):
	grid[q] = piece
	board_graphics_update(q, piece)

# just for testing:
def userplace(coor, piece):
	q = grid_user_to_main(coor)
	place(q, piece)

def adjacent_q(q):
	x,y = q
	adj_q = []
	if x != 1: 
		adj_q.append((x-1,y))
	if x != 16:
		adj_q.append((x+1,y))
	if y != 1:
		adj_q.append((x,y-1))
	if y != 11:
		adj_q.append((x,y+1))
	return adj_q

### kingdoms are recorded as a dictionary.  the key is a tuple of the leaders 
### in the kingdom (e.g., ("rl2", "gl4", "al4")), and the value of each kingdom
### is another dictionary, whose keys are "q" (q in the kingdom) and "b" (q in the
### kingdom's border).  the values of these two keys are lists of q (i.e., tuple 
### coordinates).  

def assess_kingdoms(): 
	global kingdoms
	kingdoms = {}
	leader_loc = get_leader_location()
	remaining_leaders = [leader for leader in leader_loc.keys() \
	if leader_loc[leader] != 0]
	while remaining_leaders != []:
		leader1 = remaining_leaders[0]
		leaders_in_this_kingdom = [leader1]
		q_in_this_kingdom = set([leader_loc[leader1]])
		b_of_this_kingdom = set([])
		adj_q_to_check = adjacent_q(leader_loc[leader1])
		while adj_q_to_check != []:
			add_tiles = []
			remove_tiles = []
			for q in adj_q_to_check:
				if grid[q] in ["empty","river","catastrophe"]:
					remove_tiles.append(q)
					b_of_this_kingdom.add(q)
				else:
					q_in_this_kingdom.add(q)
					remove_tiles.append(q)
					for new_q in adjacent_q(q):
						if new_q not in adj_q_to_check and \
						new_q not in add_tiles and \
						new_q not in q_in_this_kingdom:
							add_tiles.append(new_q)
					if grid[q] in leaders:
						leaders_in_this_kingdom.append(grid[q])
						remaining_leaders.remove(grid[q])
			for q in remove_tiles:
				adj_q_to_check.remove(q)
			for q in add_tiles:
				adj_q_to_check.append(q)
		kingdoms[tuple(leaders_in_this_kingdom)] = \
			{"q": list(q_in_this_kingdom), "b": list(b_of_this_kingdom)}
		remaining_leaders.remove(leader1)
	return kingdoms

def q_in_how_many_b(q):
	k_b = [kingdom for kingdom in kingdoms if (q in kingdoms[kingdom]["b"])]
	return len(k_b)

def score_for_tile(q, piece):
	assess_kingdoms()
	for kingdom in kingdoms:
		if q in kingdoms[kingdom]["q"]:
			k = kingdom
	ID = (dict(zip(clist,['r','u','a','g'])))[piece]
	if ID in [L[0] for L in k]:
		player = int([L[2] for L in k if L[0] == ID][0])
	elif 'a' in [L[0] for L in k]:
		player = int([L[2] for L in k if L[0] == "a"][0])
	else:
		player = False
	if player != False:
		color = (dict(zip(clist,[0, 1, 2, 3])))[piece]
		win_points(player, color, 1, "tile placement")

def swap_tiles(player):
	update_feed("Type the numbers next to the tiles you would like to swap.", \
		False)
	hand_list = []
	Hrange = range( 1, sum(hands[player])+1 )
	for color in range(4):
		for tile in range(hands[player][color]):
			hand_list.append(color)
	HD = dict(zip(Hrange, hand_list))
	for i in Hrange:
		update_feed("[{0}] {1}".format(i, fix_shorthand( clist[HD[i]] )),False)
	raw_tiles = feed_input('  {0}  '.format(symbols[player]), player)
	for i in Hrange:
		if str(i) in raw_tiles:
			hands[player][HD[i]] -= 1
	if sum(hands[player]) < 6:
		bag_empty = draw_tiles(player, 6 - sum(hands[player]))
	return bag_empty

def external_conflict(conflict_point, p, piece):
	s_g = beg_conflict_graphic(conflict_point)
	update_feed("", False)
	update_feed("TWO KINGDOMS ARE UNITING", False)
	pause = feed_input('...   ', p)
	leader_loc = get_leader_location()
	cons = [True, True, True, True]
	while cons.count(True) > 0:
		assess_kingdoms()
		k_in_con = [L for k_ in [k for k in kingdoms if conflict_point \
		in kingdoms[k]['b']] for L in k_]
		for i in range(4):
			if [k[0] for k in k_in_con].count(['r','u','a','g'][i]) < 2:
				cons[i] = False
		con_d = dict(zip(clist, cons))
		if cons.count(True) == 0:
			pass # should pass to end
		elif cons.count(True) == 1:
			con_col = {"red":0,"blue":1,"black":2,"green":3}[[c for c \
			in con_d if con_d[c] == True][0]]
		else:
			if human_or_comp[p] == "human":
				con_col = prompt_for_con(p, cons)
			else:
				con_col = AI_mother(p, "conflict_choice", cons)
		if cons.count(True) > 0:
			update_feed("EXTERNAL CONFLICT: {0}".format(["priests", "farmers", \
				"kings", "traders"][con_col]), True)
			base = ['r','u','a','g'][con_col]+"l"
			if base+str(p) in k_in_con:
				att_p = p
				k_in_con.remove(base+str(p))
			elif base+str(p%4+1) in k_in_con:
				att_p = p%4+1
				k_in_con.remove(base+str(p%4+1))
			else:
				att_p = (p+1)%4+1
				k_in_con.remove(base+str((p+1)%4+1))
			def_p = int([L[2] for L in k_in_con if L[:2]==base][0])

			# now we have our attacker, defender and color.

			#attacker's initial calculation
			a_k = [k for k in kingdoms if base+str(att_p) in k][0]
			akq = [grid[q] for q in kingdoms[a_k]['q']]
			att_s = akq.count(clist[con_col])
			if con_col == 0:
				att_s += akq.count("treasure")

			#defender's initial calculation
			d_k = [k for k in kingdoms if base+str(def_p) in k][0]
			dkq = [grid[q] for q in kingdoms[d_k]['q']]
			def_s = dkq.count(clist[con_col])
			if con_col == 0:
				def_s += dkq.count("treasure")

			#attacker's final calculation
			if human_or_comp[att_p] == "human":
				aadd = prompt_tile_add(att_p, con_col, att_s)
			else:
				aadd = AI_mother(att_p, "ext_tile_add", \
						(att_p, def_p, "att", con_col, att_s, def_s))
			att_s += aadd

			#defender's final claculation
			if human_or_comp[def_p] == "human":
				dadd = prompt_tile_add(def_p, con_col, def_s)
			else:
				dadd = AI_mother(def_p, "ext_tile_add", \
						(def_p, att_p, "def", con_col, att_s, def_s))
			def_s += dadd

			#resolution
			if att_s > def_s:
				winner = att_p
				loser = (def_p, d_k, base+str(def_p))
			else:
				winner = def_p
				loser = (att_p, a_k, base+str(att_p))
			update_feed("Player "+str(winner)+" has won the conflict!", False)
			place(leader_loc[loser[2]], "empty")
			losing_t = [q for q in kingdoms[loser[1]]['q'] \
				if grid[q] == clist[con_col]]
			if con_col == 0:
				ok_tiles = []
				LL = get_leader_location()
				for tile in losing_t:
					if len( set(adjacent_q(tile)) & set(LL.values()) ) > 0:
						ok_tiles.append(tile)
				for tile in ok_tiles:
					losing_t.remove(tile)
			if con_col == 1: # note -- "if" (a.o.t. elif) not a mistake! 
				for tile in losing_t:
					place(tile, "river")
			else:
				for tile in losing_t:
					place(tile, "empty")
			bounty = 1 + len(losing_t)
			win_points(winner, con_col, bounty, "the external conflict")
	end_conflict_graphic(conflict_point, s_g)
	place(conflict_point, piece)
	clear_pertinent_feed()
	pause = feed_input('Conflict resolved.  ', p)
		
def prompt_for_con(p, cons): 
	update_feed("Choose the leaders that will resolve their conflict.", False)
	choice = -1
	while choice == -1:
		c = feed_input(" {0} ".format(symbols[p]).lower(), p)
		if c.lower() == "red" or c[:6].lower() == "priest" \
								or c == "r" or c == "p":
			choice = 0
		elif c.lower() == "blue" or c[:6].lower() == "farmer" \
								or c == "f" or c == "u":
			choice = 1
		elif c.lower() == "black" or c[:4].lower() == "king" \
								or c == "k" or c == "a":
			choice = 2
		elif c.lower() == "green" or c[:6].lower() == "trader" \
								or c == "t" or c == "g":
			choice = 3
		else: 
			update_feed("Choose a valid leader", False)
		if choice in range(4) and cons[choice] == False:
			update_feed("This type of leader is not in conflict", False)
			choice = -1
	return choice
		
def prompt_tile_add(p, c, base):
	max_tiles = hands[p][c]
	update_feed("Player " + str(p) + ":", False)
	update_feed("Current conflict strength: {0}".format(base), False)
	update_feed("How many tiles would you like to add?", False)
	display_hand(p)
	while True:
		s = feed_input(" {0} ".format(symbols[p]).lower(), p)
		if s.isdigit() == False:
			update_feed("Enter a valid number.", False)
		elif int(s) > max_tiles:
			update_feed("You do not have this many tiles.", False)
		else:
			update_feed("Player {0} adds {1} tiles for a total of {2}.".format( \
			p, s, base+int(s)), True)
			hands[p][c] -= int(s)
			return int(s)

def assess_int_str(leader):
	leader_loc = get_leader_location()
	return len([q for q in adjacent_q(leader_loc[leader]) if grid[g] == "red"])

def internal_conflict(q,piece):
	assess_kingdoms()
	kdm = list([k for k in kingdoms if piece in k][0])
	if [L[:2] for L in kdm].count(piece[:2]) > 1:
		att_p = int(piece[2])
		update_feed("", False)
		update_feed("INTERNAL CONFLICT!!!", False)
		pause = feed_input('...   ', att_p)
		base_att = len([rt for rt in adjacent_q(q) \
			if (grid[rt] == "red" or grid[rt] == "treasure")])
		kdm.remove(piece)
		leader_loc = get_leader_location()
		def_q = [leader_loc[L] for L in kdm if L[:2] == piece[:2]][0]
		def_p = int(grid[def_q][2])
		base_def = len([rt for rt in adjacent_q(def_q) \
			if (grid[rt] == "red" or grid[rt] == "treasure")])

		if human_or_comp[att_p] == "human":
			att_s = base_att + prompt_tile_add(att_p, 0, base_att)
		else:
			att_s = base_att + AI_mother(att_p, "int_tile_add", \
				(att_p, def_p, "att", 0, base_att, base_def))
		
		if human_or_comp[def_p] == "human":
			def_s = base_def + prompt_tile_add(def_p, 0, base_def)
		else: 
			def_s = base_def + AI_mother(def_p, "int_tile_add", \
				(def_p, att_p, "def", 0, base_att, base_def))

		if att_s > def_s:
			winner = att_p
			loser = (int(grid[def_q][2]), def_q)
			w_is_att = True
		else:
			winner = int(grid[def_q][2])
			loser = (att_p, q)
			w_is_att = False
		update_feed("Player " + str(winner) + " has won the conflict!", True)
		place(loser[1], "empty")
		scores[winner][0] += 1
		win_points(winner, 0, 1, "the internal conflict")

def win_points(player, color, quantity, source):
	feed_input("Player {0} scores {1} {2} point{3} from {4}.".format(player, \
		quantity, clist[color], "" if quantity == 1 else "s", source), player)
	scores[player][color] += quantity

def check_treasure():
	corner_t = [ (2,2), (2,8), (16,2), (15,9) ]
	other_t = [ (6,3), (11,1), (14,5), (9,7), (6,10), (11,11) ]
	assess_kingdoms()
	klist = [K for K in kingdoms if \
		[grid[q][-8:] for q in kingdoms[K]['q']].count("treasure") > 1 and \
		[leader[0] for leader in K].count('g') == 1 ]
	if len(klist) > 0:
		for K in klist:
			player = [int(L[2]) for L in K if L[0] == 'g'][0]
			num_tr = len([q for q in kingdoms[K]['q'] if grid[q][-8:] == \
					"treasure"])
			for i in range( num_tr - 1 ):
				treas_q = [q for q in kingdoms[K]['q'] if grid[q][-8:] == \
					"treasure"]
				if len(set(treas_q) & set(corner_t)) == 1:
					pick = [q for q in treas_q if q in corner_t][0]
				else:
					if human_or_comp[player] == "human":
						update_feed("Player "+str(player)+", choose which \
treasure to take.", False)
						update_feed("(Choose the northwest space if the \
treausre is on a monument)", False)
						proceed = False
						while proceed == False:
							raw_pick = \
							feed_input(" {0} ".format(symbols[player]), player)
							pick = grid_user_to_main(raw_pick)
							if pick == False:
								update_feed("This is not a space on the \
grid.", False)
							elif pick not in corner_t + other_t:
								update_feed("There is no treasure on this \
space.", False)
							elif pick not in treas_q:
								update_feed("This treasure is not \
available.", False)
							elif pick in other_t and \
								len(set(treas_q) & set(corner_t)) > 0:
								update_feed("You must pick a corner \
treasure.", False)
							else:
								proceed = True
					else:
						pick = AI_mother(player, "treasure", treas_q)
				treas_q.remove(pick)
				update_feed("Player " +str(player) +" takes the treasure on "\
					 + grid_main_to_user(pick) + ".", False)
				treasure_count = len([q for q in corner_t+other_t if \
					grid[q][-8:] == "treasure"])
				if treasure_count > 3:
					update_feed(str(treasure_count-1)+" treasures left.", False)
				elif treasure_count == 3:
					update_feed("Only 2 treasures left.  Game ends after this \
turn.", False)
				elif treasure_count == 2:
					update_feed("Only 1 treasure left.  \
Game ends after this turn.", False)
				if grid[pick] == "treasure":
					place(pick, "red")
				elif grid[pick][-8:] == "treasure":
					new_grid_id = grid[pick][:-8]
					place(pick, new_grid_id)
				else:
					print "ERROR 003"
				scores[player][4] += 1
				pause = raw_input('   ')
	treasure_count = len([q for q in corner_t+other_t if grid[q][-8:] == \
		"treasure"])
	if treasure_count < 2:
		treasure_out = True
	else: 
		treasure_out = False
	return treasure_out

def check_monument_build(Q, player):
	X,Y = Q
	color = grid[Q]
	available_m = [M for M in monuments if color in M]
	if len(available_m) > 0:
		NWcandidates = []
		if X != 1 and Y != 1: 
			NWcandidates.append((X-1,Y-1))
		if X != 16 and Y != 1:
			NWcandidates.append((X,Y-1))
		if X != 1 and Y != 11:
			NWcandidates.append((X-1,Y))
		if X != 16 and Y != 11:
			NWcandidates.append((X,Y))
		if color == "red":
			NWcand2 = [ (x,y) for (x,y) in NWcandidates if (grid[(x,y)] == \
			"red" or grid[(x,y)] == "treasure") and (grid[(x+1,y)] == "red" \
			or grid[(x+1,y)] == "treasure") and (grid[(x,y+1)] == "red" or \
			grid[(x,y+1)]== "treasure") and (grid[(x+1,y+1)]=="red" \
			or grid[(x+1,y+1)]=="treasure")]
		else:
			NWcand2 = [ (x,y) for (x,y) in NWcandidates if grid[(x,y)] == \
			grid[(x+1,y)] == grid[(x,y+1)] == grid[(x+1,y+1)] ]
		mon = False # dummy variable set for final if clause

		if len(NWcand2) > 0 and human_or_comp[player] == "human":
			update_feed("Player {0}, choose one of the options \
below.".format(player), False)
			update_feed("[1] Take no action", False)
			update_feed("[2] Place {0} monument".format(available_m[0]), False)
			options = ['1','2']
			if len(available_m) > 1:
				update_feed("[3] Place {0} monument".format(available_m[1]), \
					False)
				options.append('3')
			if len(available_m) == 3:
				update_feed("[4] Place {0} monument".format(available_m[2]), \
					False)
				options.append('4')
			s = feed_input('  {0}  '.format(symbols[player]), player)
			while s not in options:
				update_feed("Type one of the numbers on the right \
listed above.", False)
				s = feed_input('  {0}  '.format(symbols[player]), player)
			choice = int(s)
			if choice > 1:
				mon = available_m[choice-2]
				monuments.remove(mon)
				if len(NWcand2) > 1:
					update_feed("Choose the spaces on which you would like to \
place the monument.", False)
					options = ['1','2','3'] if len(NWcand2) == 3 else ['1','2']
					for i in range(len(NWcand2)):
						x,y = NWcand2[i]
						qq = [(x,y),(x+1,y),(x,y+1),(x+1,y+1)]
						uqq = [grid_main_to_user(q) for q in qq]
						update_feed("[{0}] {1}, {2}, {3}, {4}".format(i+1, uqq[0], \
							uqq[1], uqq[2], uqq[3]), False)
					s = feed_input('  {0}  '.format(symbols[player]), player)
					while s not in options:
						update_feed("Type one of the numbers on the right \
listed above.", False)
						s = feed_input('  {0}  '.format(symbols[player]), player)
					NW_mon_dest = NWcand2[int(s)-1]
				else:
					NW_mon_dest = NWcand2[0]

		elif len(NWcand2) > 0:
			mon, NW_mon_dest = AI_mother(player, "monument", (available_m, NWcand2))

		if mon != False:
			x,y = NW_mon_dest
			treas_in_mon = False
			for q in [(x,y),(x+1,y),(x,y+1),(x+1,y+1)]:
				if grid[q] == "treasure":
					grid[q] = mon + " treasure"
					treas_in_mon = True
				else:
					grid[q] = mon
			for c in clist:
				if c in mon and c != color:
					color2 = c
			paint_monument(NW_mon_dest, color, color2, treas_in_mon)
			check_temple_support()
		

def check_temple_support():
	LL = get_leader_location()
	for leader in leaders:
		if LL[leader] != 0:
			adj_tiles = [grid[q] for q in adjacent_q(LL[leader])]
			if "red" not in adj_tiles and "treasure" not in adj_tiles:
				place(LL[leader],"empty")

def score_monuments(player):
	assess_kingdoms()
	rK = [k for k in kingdoms if 'rl'+str(player) in k]
	uK = [k for k in kingdoms if 'ul'+str(player) in k]
	aK = [k for k in kingdoms if 'al'+str(player) in k]
	gK = [k for k in kingdoms if 'gl'+str(player) in k]
	if rK != []:
		if "red - blue" in [grid[q] for q in kingdoms[rK[0]]['q']]:
			win_points(player, 0, 1, "the red-blue monument")
		if "red - black" in [grid[q] for q in kingdoms[rK[0]]['q']]:
			win_points(player, 0, 1, "the red-black monument")
		if "red - green" in [grid[q] for q in kingdoms[rK[0]]['q']]:
			win_points(player, 0, 1, "the red-green monument")
	if uK != []:
		if "red - blue" in [grid[q] for q in kingdoms[uK[0]]['q']]:
			win_points(player, 1, 1, "the red-blue monument")
		if "blue - black" in [grid[q] for q in kingdoms[uK[0]]['q']]:
			win_points(player, 1, 1, "the blue-black monument")
		if "blue - green" in [grid[q] for q in kingdoms[uK[0]]['q']]:
			win_points(player, 1, 1, "the blue-green monument")
	if aK != []:
		if "red - black" in [grid[q] for q in kingdoms[aK[0]]['q']]:
			win_points(player, 2, 1, "the red-black monument")
		if "blue - black" in [grid[q] for q in kingdoms[aK[0]]['q']]:
			win_points(player, 2, 1, "the blue-black monument")
		if "black - green" in [grid[q] for q in kingdoms[aK[0]]['q']]:
			win_points(player, 2, 1, "the black-green monument")
	if gK != []:
		if "red - green" in [grid[q] for q in kingdoms[gK[0]]['q']]:
			win_points(player, 3, 1, "the red-green monument")
		if "blue - green" in [grid[q] for q in kingdoms[gK[0]]['q']]:
			win_points(player, 3, 1, "the blue-green monument")
		if "black - green" in [grid[q] for q in kingdoms[gK[0]]['q']]:
			win_points(player, 3, 1, "the black-green monument")

def endgame_scoring():
	for i in range(20): print ""
	print "FINAL SCORING:"
	for p in range(1,5):
		print "Player {0}'s scores: red: {1}, blue: {2}, black: {3}, \
green: {4}, treasures: {5}.".format(p, scores[p][0], \
		scores[p][1], scores[p][2], scores[p][3], scores[p][4])
	print ""
	s = raw_input("   ")
	# calculate final scores:
	ordered_scores = {}
	for p in range(1,5):
		ordered_scores[p] = []
		remaining_scores = [list(tu) for tu in zip(range(4), scores[p][:4])]
		while remaining_scores != []:
			lowest_s = min([entry[1] for entry in remaining_scores])
			remove_list = []
			for color in remaining_scores:
				if color[1] == lowest_s:
					remove_list.append(color)
			for color in remove_list:
				remaining_scores.remove(color)
				ordered_scores[p].append(color)
	# [color, score] -> [c,s, treas added, total score]
	for p in range(1,5):
		for c in range(4):
			ordered_scores[p][c].append(0)
			ordered_scores[p][c].append(ordered_scores[p][c][1])
		for t in range(scores[p][4]):
			if ordered_scores[p][0][3] < ordered_scores[p][1][3]:
				# add treasure to first color
				ordered_scores[p][0][2] += 1
				ordered_scores[p][0][3] += 1
			elif ordered_scores[p][0][3] == ordered_scores[p][1][3]:
				if ordered_scores[p][1][3] < ordered_scores[p][2][3]:
					# add treasure to second color
					ordered_scores[p][1][2] += 1
					ordered_scores[p][1][3] += 1
				elif ordered_scores[p][1][3] == ordered_scores[p][2][3]:
					if ordered_scores[p][2][3] < ordered_scores[p][3][3]:
						# add treasure to third color
						ordered_scores[p][2][2] += 1
						ordered_scores[p][2][3] += 1
					elif ordered_scores[p][2][3] == ordered_scores[p][3][3]:
						# add treasure to fourth color
						ordered_scores[p][3][2] += 1
						ordered_scores[p][3][3] += 1
					else:
						print "ERROR 006"
				else:
					print "ERROR 005"
			else:
				print "ERROR 004"
	# rank players - this is a fifth entry in their ordered_scores lists
	rem_p = [1,2,3,4] # players with undetermined rank
	while rem_p != []:
		low1 = min([ordered_scores[p][0][3] for p in rem_p])
		pp1 = [p for p in rem_p if ordered_scores[p][0][3] == low1]
		if len(pp1) > 1:
			low2 = min([ordered_scores[p][1][3] for p in pp1])
			pp2 = [p for p in pp1 if ordered_scores[p][1][3] == low2]
			if len(pp2) > 1:
				low3 = min([ordered_scores[p][2][3] for p in pp2])
				pp3 = [p for p in pp2 if ordered_scores[p][2][3] == low3]
				if len(pp3) > 1:
					low4 = min([ordered_scores[p][3][3] for p in pp3])
					pp4 = [p for p in pp3 if ordered_scores[p][3][3] == low4]
					if len(pp4) > 1:
						ranking_p = max(pp4) # not in original rules: ultimate
					else:                    # ties are decided by highest 
						ranking_p = pp4[0]   # player number (i.e., latest 
				else:                        # first move)
					ranking_p = pp3[0]
			else:
				ranking_p = pp2[0]
		else:
			ranking_p = pp1[0]
		ordered_scores[ranking_p].append(len(rem_p))
		rem_p.remove(ranking_p)

	print "Place" + 3 * " " + "Player" + 3 * " " + "Lowest Score" + 11 * " " \
	+ "Second Lowest" + 10 * " " + "Third Lowest" + 11 * " " + "Fourth Lowest"

	for rank in range(4,0,-1):
		pause = raw_input(" "*100)
		P = [p for p in range(1,5) if ordered_scores[p][4] == rank][0]
		S = {1: "1st", 2: "2nd", 3: "3rd", 4:"4th"}[rank] + " " * 5 + \
		str(P) + "  " + symbols[P] * 3 + " "
		for color in range(4):
			s = NS(3,ordered_scores[P][color][1]) + " +" + \
			NS(3,ordered_scores[P][color][2]) + " =" + \
			NS(3,ordered_scores[P][color][3]) + \
			NS(8,("("+clist[ordered_scores[P][color][0]]+")"))
			S = S + s + "  "
		print S

def NS(length, x): # normalizes string to a certain length
	s = str(x)
	L = len(s)
	if length > L:
		return " " * (length - L) + s
	else:
		return s

def addrs(): # add random score - for testing
	for t in range(150):
		r1 = random()
		p = int(r1*4)+1
		r2 = random()
		c = int(r2*4)
		scores[p][c] += 1
	for t in range(8):
		r = random()
		p = int(r*4)+1
		scores[p][4] += 1


# AI


def AI_mother(p, game_step, vbs):
	s = feed_input(' {0}  AI is thinking  {0}  '.format(symbols[p]), p)
	#AI_master_dict = { "joe_youngling": {"game_move": j_y_move(vbs),
	#	"ext_tile_add": AI_basic_tile_add(vbs)}
	#return AI_master_dict[human_or_comp[p]][game_step]
	if human_or_comp[p] == "joe_youngling":
		if game_step == "game_move":
			#return j_y_move(vbs)
			return random_mover(vbs)
		elif game_step == "ext_tile_add":
			return AI_basic_tile_add(vbs)
		elif game_step == "int_tile_add":
			return AI_basic_tile_add(vbs)
		elif game_step == "conflict_choice":
			return AI_random_choosing_conflicts(vbs)
		elif game_step == "treasure":
			return AI_random_treasure_pick(vbs)
		elif game_step == "monument":
			return AI_random_mon_build(vbs)


def AI_basic_tile_add(variables):
	p, opponent, att_or_def, con_col, att_s, def_s = variables
	available = hands[p][con_col]
	if available == 0:
		addition = 0
	# if player has a chance to win, player will put as many
	# tiles as possible to ensure victory
	elif att_or_def == "att":
		if att_s + available <= def_s:
			addition = 0
		else:
			addition = max(0, min(available, def_s - att_s + 7))
	elif att_or_def == "def":
		if att_s > available + def_s or att_s <= def_s:
			addition = 0
		else:
			addition = att_s - def_s
	update_feed("Player {0} adds {1} tiles for a total of {2}.".format( \
		p, addition, addition + {"att":att_s,"def":def_s}[att_or_def]), True)
	return addition

def AI_random_choosing_conflicts(variables):
	conflict_truth_list = variables
	available_conflicts = []
	for c in range(4):
		if conflict_truth_list[c] == True:
			available_conflicts.append(c)
	return available_conflicts[int(random()*len(available_conflicts))]

def random_mover(variables):
	p, f_or_s = variables
	LL = get_leader_location()
	l_list = [l for l in LL if l[2]==str(p) and LL[l]==0]
	if l_list != []:
		r = int(random() * len(l_list))
		piece = l_list[r]
		assess_kingdoms()
		safe_dest = []
		int_conflict_dest = []
		for q in grid:
			adj_q = [grid[aq] for aq in adjacent_q(q)]
			if grid[q] != "empty":
				pass
			elif "red" not in adj_q and "treasure" not in adj_q:
				pass
			elif q_in_how_many_b(q) > 1:
				pass
			elif q_in_how_many_b(q) == 1:
				if piece[0] in [L[0] for L in \
						[K for K in kingdoms if q in kingdoms[K]['b']][0]]:
					int_conflict_dest.append(q)
				else: 
					safe_dest.append(q)
			else:
				safe_dest.append(q)
		if safe_dest != []:
			r = int(random() * len(safe_dest))
			dest = safe_dest[r]
		elif int_conflict_dest != []:
			r = int(random() * len(int_conflict_dest))
			dest = int_conflict_dest[r]
		else:
			piece = "pass"
			dest = None
	elif sum(hands[p]) > 0:
		low_score = min(scores[p])
		color_candidates = [0,1,2,3]
		for c in range(4):
			if low_score + 1 < scores[p][c]:
				color_candidates.remove(c)
			elif hands[p][c] == 0:
				color_candidates.remove(c)
		if color_candidates == []:
			color_candidates = [c for c in (0,1,2,3) if hands[p][c] > 0]
		c = pick_ran(color_candidates)
		piece = clist[c]
		assess_kingdoms()
		corr_leader = [l for l in leaders if int(l[2]) == p \
				and l[0] == ['r','u','a','g'][c]][0]
		corr_kingdom = [k for k in kingdoms if corr_leader in k][0]
		safe_dest = []
		ext_conflict_dest = []
		for q in kingdoms[corr_kingdom]['b']:
			if c == 1 and grid[q] != "river":
				pass
			elif c != 1 and grid[q] != "empty":
				pass
			elif q_in_how_many_b(q) > 2:
				pass
			elif q_in_how_many_b(q) == 2:
				ext_conflict_dest.append(q)
			else:
				safe_dest.append(q)
		if safe_dest != []:
			dest = pick_ran(safe_dest)
		elif ext_conflict_dest != []:
			dest = pick_ran(ext_conflict_dest)
		else:
			piece = "pass"
			dest = None
	else:
		piece = "pass"
		dest = None
	
		s = raw_input(' {0}                  {0}  '.format(symbols[p]))
	return (piece, dest)


def j_y_move(variables):
	p, f_or_s = variables



def AI_random_treasure_pick(variables):
	treas_q = variables
	corner_t = [ (2,2), (2,8), (16,2), (15,9) ]
	other_t = [ (6,3), (11,1), (14,5), (9,7), (6,10), (11,11) ]
	preferred_q = [q for q in treas_q if q in corner_t]
	if preferred_q != []:
		return pick_ran(preferred_q)
	else:
		return pick_ran(treas_q)


def AI_random_mon_build(variables):
	available_m, NWcandidates  = variables
	mon = pick_ran(available_m)
	NW_dest = pick_ran(NWcandidates)
	monuments.remove(mon)
	return (mon, NW_dest)



#


###

##6## game structure






###

##T## test running
print """


"""




print "   TIGRIS AND EUPHRATES"
print ""
print " set your window to at least 102 x 51  "
pause = raw_input(' '*100)

prompt_for_num_of_hum_players()
reset_variables_and_board()
initial_draw()

ok = True
p = 0
while ok != "stop":
	p = p % 4 + 1
	end_game = one_turn(p)
	if end_game == True:
		endgame_scoring()
		ok = "stop"
print """


... thank you for playing!
			"""
			





print """



"""

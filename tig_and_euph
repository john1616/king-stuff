# this program is mostly finished for human players only, but it may have bugs.  in
# the future i would like to implement computer players.  the program is being made
# for my own education and entertainment.  it is based on a board game called 
# "tigris and euphrates".  if you like the program, go buy the game!!

# it does not yet have any instructions or help.  the rules may be found online
# and the commands (though fairly obvious if you know the rules) may be easily 
# determined from the code.  

# (this code is for Python)

#					tigris and euphrates					#
#					draft number two						#



# TABLE OF CONTENTS:
# 1) notes
# 2) imports
# 3) states in the game - the location of each piece, players' hands, scores, 
#	 etc. this information would be enough to recreate a game at a given
#	 moment on a physical board. 
# 4) graphical representations - the board, as it is displayed in terminal or 
#	 whatever you're using
# 5) moves, rules and regulations
# 6) game structure - gameplay organized into a cohesive flow, i.e. a game
# T) test running



##1## notes

# sections are referred to as #1# for section 1, etc.
# terminal window should be set to at least 100x50.
# i generally use q (or (x,y)) to describe "grid" coordinates -- this is the 
# board grid as concerns gameplay.  graphics are determined by variables 
# stored in bg ("board graphics"; it is a dict of 1171 strings), and are 
# described in functions by v.  the player will see the board labled with
# letters for the horizontal axis and numbers for the vertical axis, which
# is called the coor(dinate).  

###

##2## imports:

from random import random

def num_to_alpha(x):
	if x == 1: return "A"        
	elif x == 2: return "B"
	elif x == 3: return "C"
	elif x == 4: return "D"
	elif x == 5: return "E"
	elif x == 6: return "F"
	elif x == 7: return "G"
	elif x == 8: return "H"
	elif x == 9: return "I"
	elif x == 10: return "J"
	elif x == 11: return "K"
	elif x == 12: return "L"
	elif x == 13: return "M"
	elif x == 14: return "N"
	elif x == 15: return "O"
	elif x == 16: return "P"
	elif x == 17: return "Q"
	elif x == 18: return "R"
	elif x == 19: return "S"
	elif x == 20: return "T"
	elif x == 21: return "U"
	elif x == 22: return "V"
	elif x == 23: return "W"
	elif x == 24: return "X"
	elif x == 25: return "Y"
	elif x == 26: return "Z"
	else:
		print "ERROR #001"

def alpha_to_num(letter):
	if letter.upper() == "A": x = 1
	elif letter.upper() == "B": x = 2
	elif letter.upper() == "C": x = 3
	elif letter.upper() == "D": x = 4
	elif letter.upper() == "E": x = 5
	elif letter.upper() == "F": x = 6
	elif letter.upper() == "G": x = 7
	elif letter.upper() == "H": x = 8
	elif letter.upper() == "I": x = 9
	elif letter.upper() == "J": x = 10
	elif letter.upper() == "K": x = 11
	elif letter.upper() == "L": x = 12
	elif letter.upper() == "M": x = 13
	elif letter.upper() == "N": x = 14
	elif letter.upper() == "O": x = 15
	elif letter.upper() == "P": x = 16
	elif letter.upper() == "Q": x = 17
	elif letter.upper() == "R": x = 18
	elif letter.upper() == "S": x = 19
	elif letter.upper() == "T": x = 20
	elif letter.upper() == "U": x = 21
	elif letter.upper() == "V": x = 22
	elif letter.upper() == "W": x = 23
	elif letter.upper() == "X": x = 24
	elif letter.upper() == "Y": x = 25
	elif letter.upper() == "Z": x = 26
	else:
		print "ERROR #002"
	return x

###

##3## states in the game

# there will be a number of lists/dicts/sets for keeping track of the elements
# of the game, some of are dependent on others (for example, a list of
# locations on the board and what pieces, if any, are on them).  there will
# be functions that update the dependent lists (which must be called before
# any of the dependent lists are used).
#
# game board:
# the board is 16 x 11.  it is marked (for the human player) as A to P on the
# horizontal axis and 1 to 11 on the vertical axis.  i will keep these
# coordinates in the program mechanics, but will use integers for A to P
# (i.e., 1 to 16).  thus, the grid of the game board (and what is on the grid)
# will be represented by a dict of 176 tuples, from (1,1) to (11,16).  the
# values of these tuples may one of the following strings (not written here
# with ""; remarks in parentheses are not included in the string):
#
#	empty			river
#	red (tile)		blue (tile)		black (tile)	green (tile)
#	rl1 (red leader of player 1)	al1 (black leader of player 1)
#	ul1 (blue leader of player 1)	gl1 (green leader of player 1)
#	rl2 ... 						... gl4
#	catastrophe			monument (NW/NE/SW/SE; of two colors)
#	red w treasure		monument w treasure
#
# in the original game, there are two rivers that run across the board.  here,
# that setup will be the default, but i will construct the program to allow
# for a way to make a custom river.  

def create_main_grid():         # creates a dict that has coordinates on the
	grid = {}                   # board as keys and strings as values, which
	for i in range(1,17):       # represent the pieces on the board.  
		for j in range(1,12):
			grid[(i,j)] = "empty"
	return grid

def grid_main_to_user(q):   	# translates a tuple coordinate on the board
	x, y = q					# to the corresponding string that would be
	coor = ""                   # used and understood by the human player
	coor += num_to_alpha(x)
	coor += str(y)
	return coor

def grid_user_to_main(coor):    		# translates a coordinate as a letter-
	if coor == "": 
		return False
	elif coor.lower() == "remove":
		return 0
	elif coor[0].lower() not in ['a','b','c','d','e','f','g','h', \
	'i','j','k','l','m','n','o','p']:   # number string to a tuple coordinate.
		return False					# returns False in case of an error
	elif coor[1:].isdigit() == False:
		return False
	elif int(coor[1:]) > 11 or int(coor[1:]) < 1:
		return False
	else:
		x = alpha_to_num(coor[0])
		y = int(coor[1:])
		return (x,y)

def define_default_river():		# simply returns the coordinates of the river
	river1 = [(1,4),(2,4),(3,4),(4,4),(4,3),(5,3),(5,2),(5,1), \
			(6,1),(7,1),(8,1),(9,1)]

	river2 = [(1,7),(2,7),(3,7),(4,7),(4,8),(5,8),(6,8),(7,8),(7,9), \
		(8,9),(9,9),(10,9),(11,9),(12,9),(13,9),(13,8),(13,7),(14,7),(15,7), \
		(15,6),(15,5),(16,5),(16,4),(15,4),(14,4),(14,3),(13,3),(13,2),(13,1)]

	return (river1,river2)

def define_default_treasure():	# returns coordinates of the treasures
	return [(2,2),(6,3),(11,1),(16,2),(14,5),(9,7),(2,8),(6,10),(11,11),(15,9)]

def get_leader_location():
	leader_loc = {"rl1":0,"ul1":0,"al1":0,"gl1":0,"rl2":0,"ul2":0,"al2":0, \
	"gl2":0,"rl3":0,"ul3":0,"al3":0,"gl3":0,"rl4":0,"ul4":0,"al4":0,"gl4":0}
	for q in grid:
		if grid[q] in leaders:
			leader_loc[grid[q]] = q
	return leader_loc

def randomly_assign_player_symbols():
	symbols = {1:0,2:0,3:0,4:0}
	available_symbols = ["o","x","+","*"]
	r1 = random()
	if r1 < .25:
		symbols[1] = available_symbols[0]
		available_symbols.remove(symbols[1])
	elif r1 < .5:
		symbols[1] = available_symbols[1]
		available_symbols.remove(symbols[1])
	elif r1 < .75:
		symbols[1] = available_symbols[2]
		available_symbols.remove(symbols[1])
	else:
		symbols[1] = available_symbols[3]
		available_symbols.remove(symbols[1])
	r2 = random()
	if r2 < .3333:
		symbols[2] = available_symbols[0]
		available_symbols.remove(symbols[2])
	elif r2 < .6667:
		symbols[2] = available_symbols[1]
		available_symbols.remove(symbols[2])
	else:
		symbols[2] = available_symbols[2]
		available_symbols.remove(symbols[2])
	r3 = random()
	if r3 < .5:
		symbols[3] = available_symbols[0]
		available_symbols.remove(symbols[3])
	else:
		symbols[3] = available_symbols[1]
	symbols[4] = available_symbols[0]
	return symbols

def reset_variables_and_board():
	# here's where there would be a control on which river / treasure to pick
	# (instead of using the defaults found in the original game)

	global human_or_comp
	global leaders
	global symbols
	global grid
	global bg
	global scores
	global bag
	global hands
	global catastrophes
	global kingdoms
	global monuments
	global clist
	global log
	
	human_or_comp = ["human","human","human","human","human"] # for now..
	
	leaders = ["rl1","rl2","rl3","rl4","ul1","ul2","ul3","ul4", \
			   "al1","al2","al3","al4","gl1","gl2","gl3","gl4"]

	symbols = randomly_assign_player_symbols()
	grid = create_main_grid()
	bg = reset_board_graphics()

	rivers = define_default_river()
	for q in [q for river in rivers for q in river]:
		grid[q] = "river"
	set_river_graphics(rivers,bg) # defined below, in #4#

	treasure = define_default_treasure()
	for q in treasure: 
		place(q, "treasure") # this is a key function, found in #5#

	scores = {1:[0,0,0,0,0],2:[0,0,0,0,0],3:[0,0,0,0,0],4:[0,0,0,0,0]}
	bag = [47,36,30,30] # red, blue, black, green tiles remaining
	hands = {1:[0,0,0,0], 2:[0,0,0,0], 3:[0,0,0,0], \
			4:[0,0,0,0]} # these will be filled in #5#
	catastrophes = {1:2,2:2,3:2,4:2}
	kingdoms = {}
	monuments = ["red - blue", "red - black", "red - green", "blue - black", \
					"blue - green", "black - green"]
	clist = ["red","blue","black","green"]
	log = [] # for the use of the AI

###

##4## graphical representations

# i am using a lot of variables, many of which will not get used (very much).  
# the game board is 16 x 11, but each tile is going to consist of a 5 x 3
# square (including the lower border but not the sides).  each of the three
# lines of the interior of a tile will have a separate variable (that is, a
# value in a dict), and each piece of the side borders will also have a
# variable (which will usually just be a vertical bar, '|').  almost all of
# the graphical variation will occur on the middle variable.  each spot on the
# board will be assigned a number:

#	 ___________	0( 1 )2( 3 )4(... 		the top line will have only 33
#	|     |     |	33(34)35(36)37...		variables, but all others will
#	| *** |   r r	67(68)69(70)71...		have 34.  of the variables shown
#	|_____|__r__|	|_____|__r__|			to the left, 68 and 70 are the
#	|     |  r  |	|     |  r  |			only ones that would be affected
#	|     | *** |	|     | *** |			by the majority of in-game play.
#	|_____|__r__|	|_____|__r__|	
#
#


def reset_board_graphics():
	bg = {}
	for v in range(1171):
		bg[v] = "x"
	bg[0] = " "
	bg[32] = "   "
	for v in range(1,32,2):
		bg[v] = "_____"
	for v in range(2,31,2):
		bg[v] = "_"
	for v in range(33,1155,2):
		bg[v] = "|"
	for v in range(66,1155,34):
		bg[v] = "   "
	for v in range(100,1155,102):
		bg[v] = " %s" % ( (v-100)/102 + 1 )
	for row in range(1,34,3):
		for v in range(row*34,row*34+31,2):
			bg[v] = "     "
	for row in range(2,34,3):
		for v in range(row*34,row*34+31,2):
			bg[v] = "     "
	for row in range(3,34,3):
		for v in range(row*34,row*34+31,2):
			bg[v] = "_____"
	for v in range(1155,1171):
		bg[v] = "   %s  " % (num_to_alpha(v-1154))
	return bg


def set_river_graphics(rivers,bg):
	for river in rivers:
		for q in [river[0]]: #first endpoint
			if q[0] == 1:
				bg[q_to_v(q)-1] = "r"
				if river[1][0] == 1:
					bg[q_to_v(q)] = " r   "
				else:
					bg[q_to_v(q)] = " r r "
			elif q[0] == 16:
				bg[q_to_v(q)+1] = "r"
				if river[1][0] == 16:
					bg[q_to_v(q)] = "   r "
				else:
					bg[q_to_v(q)] = " r r "
			elif q[1] == 1:
				bg[q_to_v(q)-34] = "  r  "
				bg[q_to_v(q)-67] = "__r__"
				if river[1][1] == 2:
					bg[q_to_v(q)] = "  r  "
				elif river[1][0] == q[0] + 1:
					bg[q_to_v(q)] = "   r "
				elif river[1][0] == q[0] - 1:
					bg[q_to_v(q)] = " r   "
			elif q[1] == 11:
				bg[q_to_v(q)+34] = "___r_"
				if river[1][1] == 10:
					bg[q_to_v(q)] = "  r  "
				elif river[1][0] == q[0] + 1:
					bg[q_to_v(q)] = "   r "
				elif river[1][0] == q[0] - 1:
					bg[q_to_v(q)] = " r   "
		for q in [river[-1]]: # 2nd endpoint
			if q[0] == 1:
				bg[q_to_v(q)-1] = "r"
				if river[-2][0] == 1:
					bg[q_to_v(q)] = " r   "
				else:
					bg[q_to_v(q)] = " r r "
			elif q[0] == 16:
				bg[q_to_v(q)+1] = "r"
				if river[-2][0] == 16:
					bg[q_to_v(q)] = "   r "
				else:
					bg[q_to_v(q)] = " r r "
			elif q[1] == 1:
				bg[q_to_v(q)-34] = "  r  "
				bg[q_to_v(q)-67] = "__r__"
				if river[-2][1] == 2:
					bg[q_to_v(q)] = "  r  "
				elif river[-2][0] == q[0] + 1:
					bg[q_to_v(q)] = "   r "
				elif river[-2][0] == q[0] - 1:
					bg[q_to_v(q)] = " r   "
			elif q[1] == 11:
				bg[q_to_v(q)+34] = "___r_"
				if river[-2][1] == 10:
					bg[q_to_v(q)] = "  r  "
				elif river[-2][0] == q[0] + 1:
					bg[q_to_v(q)] = "   r "
				elif river[-2][0] == q[0] - 1:
					bg[q_to_v(q)] = " r   "
		for bo in range(len(river)-1): # border btwn middle river sections
			if river[bo][0] + 1 == river[bo+1][0]:
				bg[q_to_v(river[bo])+1] = "r"
			elif river[bo][0] - 1 == river[bo+1][0]:
				bg[q_to_v(river[bo])-1] = "r"
			elif river[bo][1] + 1 == river[bo+1][1]:
				bg[q_to_v(river[bo])+34] = "__r__"
				bg[q_to_v(river[bo])+68] = "  r  "
			elif river[bo][1] - 1 == river[bo+1][1]:
				bg[q_to_v(river[bo])-34] = "  r  "
				bg[q_to_v(river[bo])-68] = "__r__"
		for m in range(1,len(river)-1): # main v for middle river sections
			if river[m][0] + 1 == river[m+1][0] or \
			river[m][0] + 1 == river[m-1][0]:
				if river[m][0] - 1 == river[m+1][0] or \
				river[m][0] - 1 == river[m-1][0]:
					bg[q_to_v(river[m])] = " r r "
				else:
					bg[q_to_v(river[m])] = "   r "
			else:
				if river[m][0] - 1 == river[m+1][0] or \
				river[m][0] - 1 == river[m-1][0]:
					bg[q_to_v(river[m])] = " r   "
				else:
					bg[q_to_v(river[m])] = "  r  "


def q_to_v(q):
	x, y = q
	v = 2 * x + y * 102 - 36
	return v

def board_graphics_update(q, piece): # will have to change this if
	v = q_to_v(q)                    # forks in the river are allowed
	if piece == "river":
		river_graphics_update(v)
	elif piece == "empty": 
		bg[v-34] = "     "
		bg[v] = "     "
		bg[v+34] = "_____"
	elif piece == "red":
#		bg[v-34] = ".   ."
		bg[v-34] = "     "
		bg[v] = " tem "
#		bg[v+34] = ".___."
	elif piece == "blue":
		bg[v] = " frm "
#		if bg[v-34][2] == "r":
#			bg[v-34] = ". r ."
#		else:
#			bg[v-34] = ".   ."
#		if bg[v+34][2] == "r":
#			bg[v+34] = "._r_."
#		else:
#			bg[v+34] = ".___."

#	elif piece == "blue" and 1 ==2:		# debatable what the best
#		if bg[v-34][2] == "r":			# graphic for farms (on
#			N = True 					# rivers) is.  sticking
#			bg[v-34] = ". r ."			# with a simple option here
#		else:
#			N = False
#			bg[v-34] = ".   ."
#		if bg[v+34][2] == "r":
#			S = True
#			bg[v+34] = "._r_."
#		else:
#			S = False
#			bg[v+34] = ".___."
#		if bg[v-1] == "r":
#			if N or S:
#				bg[v] = " frm "
#			else:
#				bg[v] = " frm "
#		elif bg[v+1] == "r":
#			bg[v] = " frm "
#		bg[v-34] = ". r ."
#		bg[v+34] = "._r_."

	elif piece == "black":
#		bg[v-34] = ".   ."
		bg[v] = " set "
#		bg[v+34] = ".___."
	elif piece == "green":
#		bg[v-34] = ".   ."
		bg[v] = " mkt "
#		bg[v+34] = ".___."
	elif piece in leaders:
		if piece[0] == "r":
			bg[v] = " PST "
		elif piece[0] == "u":
			bg[v] = " FMR "
		elif piece[0] == "a":
			bg[v] = " KNG "
		elif piece[0] == "g":
			bg[v] = " TDR "
		p = int(piece[2])
		bg[v-34] = symbols[p] + " " + piece[2] + " " + symbols[p]
		bg[v+34] = symbols[p] + "_" + piece[2] + "_" + symbols[p]
	elif piece == "treasure":
		bg[v] = " tem "
		bg[v-34] = " $$$ "
	elif piece == "catastrophe":
		bg[v-34] = " X X "
		bg[v] = "X 0 X"
		bg[v+34] = "_X_X_"


def river_graphics_update(v):
	if bg[v+1] == "r":
		if bg[v-1] == "r":
			bg[v] = " r r "
		else:
			bg[v] = "   r "
	else:
		if bg[v-1] == "r":
			bg[v] = " r   "
		else:
			bg[v] = "  r  "
	if bg[v-34][2] == "r":
		bg[v-34] = "  r  "
	else: 
		bg[v-34] = "     "
	if bg[v+34][2] == "r":
		bg[v+34] = "__r__"
	else: 
		bg[v+34] = "_____"

def paint_monument(NWq, color1, color2, treasure_in_mon):
	bg[q_to_v(NWq)-34] = " +---"
	bg[q_to_v(NWq)-33] = "-"
	bg[q_to_v(NWq)-32] = "---+ "
	if color1 == "red":
		bg[q_to_v(NWq)] = " |  R"
	elif color1 == "green":
		bg[q_to_v(NWq)] = " | GR"
	else:
		bg[q_to_v(NWq)] = " | BL"
	if color1 == "black":
		bg[q_to_v(NWq)+1] = "A"
	elif color1 == "blue":
		bg[q_to_v(NWq)+1] = "U"
	else:
		bg[q_to_v(NWq)+1] = "E"
	if color1 == "red":
		bg[q_to_v(NWq)+2] = "D  | "
	elif color1 == "green":
		bg[q_to_v(NWq)+2] = "EN | "
	elif color1 == "black":
		bg[q_to_v(NWq)+2] = "CK | "
	else:
		bg[q_to_v(NWq)+2] = "E  | "
	if treasure_in_mon == True:
		bg[q_to_v(NWq)+34] = " |  $"
		bg[q_to_v(NWq)+35] = "$"
		bg[q_to_v(NWq)+36] = "$  | "
	else:
		bg[q_to_v(NWq)+34] = " |   "
		bg[q_to_v(NWq)+35] = " "
		bg[q_to_v(NWq)+36] = "   | "
	if color2 == "red":
		bg[q_to_v(NWq)+68] = " |  R"
	elif color2 == "green":
		bg[q_to_v(NWq)+68] = " | GR"
	elif color2 == "blue":
		bg[q_to_v(NWq)+68] = " |  B"
	else:
		bg[q_to_v(NWq)+68] = " | BL"
	if color2 == "black":
		bg[q_to_v(NWq)+69] = "A"
	elif color2 == "blue":
		bg[q_to_v(NWq)+69] = "L"
	else:
		bg[q_to_v(NWq)+69] = "E"
	if color2 == "red":
		bg[q_to_v(NWq)+70] = "D  | "
	elif color2 == "green":
		bg[q_to_v(NWq)+70] = "EN | "
	elif color2 == "black":
		bg[q_to_v(NWq)+70] = "CK | "
	else:
		bg[q_to_v(NWq)+70] = "UE | "
	bg[q_to_v(NWq)+102] = " +---"
	bg[q_to_v(NWq)+103] = "-"
	bg[q_to_v(NWq)+104] = "---+ "

def beg_conflict_graphic(q):
	vtop = bg[q_to_v(q)-34]
	vmid = bg[q_to_v(q)]
	vbot = bg[q_to_v(q)+34]
	stored_graphics = (vtop, vmid, vbot)
	bg[q_to_v(q)-34] = "\ | /"
	bg[q_to_v(q)] = "- * -"
	bg[q_to_v(q)+34] = "/_|_\\"
	return stored_graphics

def end_conflict_graphic(q, stored_graphics): 
	vtop, vmid, vbot = stored_graphics
	bg[q_to_v(q)-34] = vtop
	bg[q_to_v(q)] = vmid
	bg[q_to_v(q)+34] = vbot

def print_board():
	print """






	"""
	rows = [""]*35	
	for v in range(33):
		rows[0] += bg[v]
	for row in range(1,34):
		for v in range(row*34-1,row*34+33):
			rows[row] += bg[v]
	for v in range(1155,1171):
		rows[34] += bg[v]
	for row in rows:
		print row
	print ""
	return rows


###

##5## moves, rules and regulations

def initial_draw():
	for p in range(1,5):
		draw_tiles(p, 6)

def draw_tiles(p, num):
	for i in range(num):
		if sum(bag) == 0:
			bag_empty = True
			print ""
			print "The tiles have run out!"
		else:
			bag_empty = False
			r = random() * sum(bag)
			if r < bag[0]: 
				hands[p][0] += 1
				bag[0] -= 1
			elif r < bag[0]+bag[1]:
				hands[p][1] += 1
				bag[1] -= 1
			elif r < bag[0]+bag[1]+bag[2]:
				hands[p][2] += 1
				bag[2] -= 1
			else:
				hands[p][3] += 1
				bag[3] -= 1
	return bag_empty

def one_turn(p):
	print_board()
	print "Player {0}, it is your turn.".format(p)
	bag_empty = False
	treas_gone, end_game_now = one_move(p, "first")
	print_board()
	if end_game_now == False:
		treas_gone, end_game_now = one_move(p, "second")
		score_monuments(p)
		for player in range(1,5):
			if sum(hands[player]) < 6:
				bag_empty = draw_tiles(player, 6 - sum(hands[player]))
	if bag_empty == True or treas_gone == True or end_game_now == True:
		end_game = True
	else:
		end_game = False
	return end_game

def print_scores(player):
	print ""
	for p in range(1,5):
		print "Player {0}'s scores: red: {1}, blue: {2}, black: {3}, \
green: {4}, treasures: {5}.  {6}".format(p, scores[p][0], \
		scores[p][1], scores[p][2], scores[p][3], scores[p][4], \
		symbols[p] if p==player else "")
	s = raw_input("...   ")
	if s[:4] == "show":
		s2 = raw_input("   ")
		q = grid_user_to_main(s2)
		if q != False:
			print grid[q]
		else:
			print ".not a correct grid q."
	elif s == "kingdoms":
		assess_kingdoms()
		print kingdoms
	s = raw_input("...   ")

def one_move(player, f_or_s):
	p = player
	if human_or_comp[p] == "human":
		piece, dest = prompt_move(p, f_or_s)
	else:
		piece, dest = AI_mother(p) # assuming AI never makes invalid move...
	return make_move(dest, piece, player)

def display_hand(p):
	print "Player {0}'s hand: {1} temple{2}, {3} farm{4}, {5} settlement{6} and {7} \
market{8}.".format(p, hands[p][0], "" if hands[p][0]==1 else "s", hands[p][1], \
	"" if hands[p][1]==1 else "s", hands[p][2], "" if hands[p][2]==1  \
	else "s", hands[p][3], "" if hands[p][3]==1 else "s")
	print ""

def prompt_move(p, f_or_s):
	print "Your {0} action: place a tile, move a leader, \
inflict a catastrophe or swap tiles.".format(f_or_s)
	display_hand(p)
	move_ok = False
	while move_ok == False:
		piece = fix_shorthand(raw_input(" {0} ".format(symbols[p])) )
		if piece == "scores":
			print_scores(p)
		elif piece == "leaders":
			print show_leaders(p)
		elif piece == "swap":
			return ("swap", None)
		elif piece == False: # responds to invalid input
			print "This is not a valid move."
		elif (piece == "temple" and hands[p][0] == 0) or \
			(piece == "farm" and hands[p][1] == 0) or \
			(piece == "settlement" and hands[p][2] == 0) or \
			(piece == "market" and hands[p][3] == 0):
			print "You do not have any tiles of type.  Choose another move."
		elif piece == "catastrophe" and catastrophes[p] == 0:
			print "You do not have any catastrophes left.  Choose another move."
		else:
			print "Where would you like to place the " + piece + "?"
			raw_dest = raw_input(" {0} ".format(symbols[p]))
			if raw_dest != "redo":
				dest = grid_user_to_main(raw_dest)
				move_ok = True
			else:
				print "Place a tile, move a leader, \
inflict a catastrophe or swap tiles."
	move_ok = False
	piece = translate_piece(piece, p)
	while move_ok == False:
		print ""
		if dest == False:
			print "This is not a valid coordinate on the grid."
		else:
			valid = validmove(piece,dest)
			if valid != True:
				print valid
			else:
				move_ok = True
		if move_ok == False:
			print ""
			dest = grid_user_to_main(raw_input(" {0} ".format(symbols[p])))
	return (piece, dest)

def show_leaders(p):
	LL = get_leader_location()
	free_L = [fix_shorthand(L[:2]) for L in leaders if LL[L] == 0 and L[2] == str(p)]
	if free_L == []:
		return "All leaders are on the board."
	else:
		L_s = "Leaders not on board: "
		for L in free_L:
			L_s = L_s + L + ", "
	return L_s[:-2] + "."

def fix_shorthand(raw_s):
	s = raw_s.lower()
	if s == "red" or s == "tem" or s == "t" or s == "temple":
		return "temple"
	elif s == "blue" or s == "fa" or s == "f" or s == "farm": 
		return "farm"
	elif s == "black" or s == "set" or s == "s" or s == "settlement": 
		return "settlement"
	elif s == "green" or s == "mar" or s == "m" or s == "market": 
		return "market"
	elif s == "pri" or s == "p" or s == "rl" or s == "priest": 
		return "priest"
	elif s == "fr" or s == "ul" or s == "farmer": 
		return "farmer"
	elif s == "kg" or s == "k" or s == "al" or s == "king": 
		return "king"
	elif s == "tr" or s == "t" or s == "gl" or s == "trader": 
		return "trader"
	elif s == "cat" or s == "catastrophe": 
		return "catastrophe"
	elif s == "swap":
		return "swap"
	elif s == "scores":
		return "scores"
	elif s == "leaders":
		return "leaders"
	else:
		return False

def translate_piece(piece, player): # i used different terminology in the code
	if piece == "temple": return "red"
	if piece == "farm": return "blue"
	if piece == "settlement": return "black"
	if piece == "market": return "green"
	if piece == "priest": return "rl" + str(player)
	if piece == "farmer": return "ul" + str(player)
	if piece == "king": return "al" + str(player)
	if piece == "trader": return "gl" + str(player)
	if piece == "catastrophe": return "catastrophe"

def validmove(piece, dest):
	if piece not in leaders and dest == 0:
		return "Only leaders may be removed from the board."
	elif piece == "catastrophe":              # a valid move returns True;
		if grid[dest] == "catastrophe":		# else returns error message
			return "You may not place a catastrophe on another catastrophe."
		elif grid[dest] in leaders:
			return "You may not place a catastrophe on a leader."
		else:
			return True
	elif piece in clist:
		if grid[dest] not in ["empty","river"]:
			return "You must place a tile on an unoccupied space."
		elif grid[dest] == "river" and piece != "blue":
			return "Only farms may be placed on river spaces."
		elif grid[dest] != "river" and piece == "blue":
			return "Farms must be placed on river spaces."
		elif q_in_how_many_b(dest) > 2 :
			return "You may not join three or four kingdoms at one time."
		else:
			return True
	elif piece in leaders:
		if grid[dest] == piece:
			return "This leader is already at this location."
		elif grid[dest] not in ["empty","river"]:
			return "You must place a leader on an unoccupied space."
		elif grid[dest] == "river":
			return "You may not place a leader on a river space."
		elif "red" not in [grid[adj_q] for adj_q in adjacent_q(dest)] and \
			"treasure" not in [grid[adj_q] for adj_q in adjacent_q(dest)]:
			return "Leaders must be placed next to a temple."
		else:
			leader_loc = get_leader_location()
			if leader_loc[piece] != 0:
				save_q = grid[leader_loc[piece]]
				place(leader_loc[piece], "empty")
				assess_kingdoms()
				if q_in_how_many_b(dest) > 1:
					place(leader_loc[piece], piece)
					return "You may not join kingdoms with a leader."
				else: return True
			else: return True
	else:
		return "Enter a valid piece to move" # probably not necessary

def make_move(dest, piece, player):
	end_game_now = False
	if piece == "swap":
		end_game_now = swap_tiles(player)
	elif piece == "catastrophe":
		place(dest, piece)
		check_temple_support()
		catastrophes[player] -= 1
	else:
		assess_kingdoms()
		bordering = q_in_how_many_b(dest)
		if piece in clist:
			hands[player][dict(zip(clist,[0,1,2,3]))[piece]] -= 1
			if bordering == 2:
				external_conflict(dest, player, piece)
			else:
				place(dest, piece)
				print_board()
				if bordering == 1:
					score_for_tile(dest, piece)
			check_monument_build(dest, player)
		elif piece in leaders:
			place(dest, piece)
			print_board()
			if bordering == 1:
				internal_conflict(dest, piece)
	treas_gone = check_treasure()
	return (treas_gone, end_game_now)

def place(q, piece):
	grid[q] = piece
	board_graphics_update(q, piece)

# just for testing:
def userplace(coor, piece):
	q = grid_user_to_main(coor)
	place(q, piece)

def adjacent_q(q):
	x,y = q
	adj_q = []
	if x != 1: 
		adj_q.append((x-1,y))
	if x != 16:
		adj_q.append((x+1,y))
	if y != 1:
		adj_q.append((x,y-1))
	if y != 11:
		adj_q.append((x,y+1))
	return adj_q

### kingdoms are recorded as a dictionary.  the key is a tuple of the leaders 
### in the kingdom (e.g., ("rl2", "gl4", "al4")), and the value of each kingdom
### is another dictionary, whose keys are "q" (q in the kingdom) and "b" (q in the
### kingdom's border).  the values of these two keys are lists of q (i.e., tuple 
### coordinates).  

def assess_kingdoms(): 
	global kingdoms
	kingdoms = {}
	leader_loc = get_leader_location()
	remaining_leaders = [leader for leader in leader_loc.keys() \
	if leader_loc[leader] != 0]
	while remaining_leaders != []:
		leader1 = remaining_leaders[0]
		leaders_in_this_kingdom = [leader1]
		q_in_this_kingdom = set([leader_loc[leader1]])
		b_of_this_kingdom = set([])
		adj_q_to_check = adjacent_q(leader_loc[leader1])
		while adj_q_to_check != []:
			add_tiles = []
			remove_tiles = []
			for q in adj_q_to_check:
				if grid[q] in ["empty","river","catastrophe"]:
					remove_tiles.append(q)
					b_of_this_kingdom.add(q)
				else:
					q_in_this_kingdom.add(q)
					remove_tiles.append(q)
					for new_q in adjacent_q(q):
						if new_q not in adj_q_to_check and \
						new_q not in add_tiles and \
						new_q not in q_in_this_kingdom:
							add_tiles.append(new_q)
					if grid[q] in leaders:
						leaders_in_this_kingdom.append(grid[q])
						remaining_leaders.remove(grid[q])
			for q in remove_tiles:
				adj_q_to_check.remove(q)
			for q in add_tiles:
				adj_q_to_check.append(q)
		kingdoms[tuple(leaders_in_this_kingdom)] = \
			{"q": list(q_in_this_kingdom), "b": list(b_of_this_kingdom)}
		remaining_leaders.remove(leader1)
	return kingdoms

def q_in_how_many_b(q):
	k_b = [kingdom for kingdom in kingdoms if (q in kingdoms[kingdom]["b"])]
	return len(k_b)

def score_for_tile(q, piece):
	assess_kingdoms()
	for kingdom in kingdoms:
		if q in kingdoms[kingdom]["q"]:
			k = kingdom
	ID = (dict(zip(clist,['r','u','a','g'])))[piece]
	if ID in [L[0] for L in k]:
		player = int([L[2] for L in k if L[0] == ID][0])
	elif 'a' in [L[0] for L in k]:
		player = int([L[2] for L in k if L[0] == "a"][0])
	else:
		player = False
	if player != False:
		color = (dict(zip(clist,[0, 1, 2, 3])))[piece]
		win_points(player, color, 1, "tile placement")

def swap_tiles(player):
	print "Type the numbers next to the tiles you would like to swap."
	hand_list = []
	Hrange = range( 1, sum(hands[player])+1 )
	for color in range(4):
		for tile in range(hands[player][color]):
			hand_list.append(color)
	HD = dict(zip(Hrange, hand_list))
	for i in Hrange:
		print "[{0}] {1}".format(i, fix_shorthand( clist[HD[i]] ))
	raw_tiles = raw_input('  {0}  '.format(symbols[player]))
	for i in Hrange:
		if str(i) in raw_tiles:
			hands[player][HD[i]] -= 1
	if sum(hands[player]) < 6:
		bag_empty = draw_tiles(player, 6 - sum(hands[player]))
	return bag_empty

def external_conflict(conflict_point, p, piece):
	s_g = beg_conflict_graphic(conflict_point)
	print_board()
	print ""
	print "TWO KINGDOMS ARE UNITING"
	pause = raw_input('...   ')
	print ""
	leader_loc = get_leader_location()
	cons = [True, True, True, True]
	while cons.count(True) > 0:
		print_board()
		print ""
		assess_kingdoms()
		k_in_con = [L for k_ in [k for k in kingdoms if conflict_point \
		in kingdoms[k]['b']] for L in k_]
		for i in range(4):
			if [k[0] for k in k_in_con].count(['r','u','a','g'][i]) < 2:
				cons[i] = False
		con_d = dict(zip(clist, cons))
		if cons.count(True) == 0:
			pass # should pass to end
		elif cons.count(True) == 1:
			con_col = {"red":0,"blue":1,"black":2,"green":3}[[c for c \
			in con_d if con_d[c] == True][0]]
		else:
			if human_or_comp[p] == "human":
				con_col = prompt_for_con(p, cons)
			else:
				con_col = AI_choosing_conflicts()
		if cons.count(True) > 0:
			print "EXTERNAL CONFLICT: {0}".format(["priests", "farmers", \
				"kings", "traders"][con_col])
			print ""
			base = ['r','u','a','g'][con_col]+"l"
			if base+str(p) in k_in_con:
				att_p = p
				k_in_con.remove(base+str(p))
			elif base+str(p%4+1) in k_in_con:
				att_p = p%4+1
				k_in_con.remove(base+str(p%4+1))
			else:
				att_p = (p+1)%4+1
				k_in_con.remove(base+str((p+1)%4+1))
			def_p = int([L[2] for L in k_in_con if L[:2]==base][0])

			# now we have our attacker, defender and color.

			#attacker's calculation
			a_k = [k for k in kingdoms if base+str(att_p) in k][0]
			akq = [grid[q] for q in kingdoms[a_k]['q']]
			att_s = akq.count(clist[con_col])
			if con_col == 0:
				att_s += akq.count("treasure")
			if human_or_comp[att_p] == "human":
				aadd = prompt_tile_add(att_p, con_col, att_s)
			else:
				aadd = AI_tile_add()
			att_s += aadd

			#defender's calculation
			d_k = [k for k in kingdoms if base+str(def_p) in k][0]
			dkq = [grid[q] for q in kingdoms[d_k]['q']]
			def_s = dkq.count(clist[con_col])
			if con_col == 0:
				def_s += dkq.count("treasure")
			if human_or_comp[def_p] == "human":
				dadd = prompt_tile_add(def_p, con_col, def_s)
			else:
				dadd = AI_tile_add()
			def_s += dadd

			#resolution
			if att_s > def_s:
				winner = att_p
				loser = (def_p, d_k, base+str(def_p))
			else:
				winner = def_p
				loser = (att_p, a_k, base+str(att_p))
			print "Player", winner, "has won the conflict!"
			place(leader_loc[loser[2]], "empty")
			losing_t = [q for q in kingdoms[loser[1]]['q'] \
				if grid[q] == clist[con_col]]
			if con_col == 0:
				ok_tiles = []
				LL = get_leader_location()
				for tile in losing_t:
					if len( set(adjacent_q(tile)) & set(LL.values()) ) > 0:
						ok_tiles.append(tile)
				for tile in ok_tiles:
					losing_t.remove(tile)
			if con_col == 1: # note -- "if" (a.o.t. elif) not a mistake! 
				for tile in losing_t:
					place(tile, "river")
			else:
				for tile in losing_t:
					place(tile, "empty")
			bounty = 1 + len(losing_t)
			win_points(winner, con_col, bounty, "the external conflict")
	end_conflict_graphic(conflict_point, s_g)
	place(conflict_point, piece)
	print_board()
	print ""
	print "Conflict resolved."
	pause = raw_input(' . . . ')
	if pause == "scores": print_scores(p)
		
def prompt_for_con(p, cons):
	print ""
	print "Choose the leaders that will resolve their conflict."
	proceed = False
	while proceed == False:
		print ""
		c = raw_input(" {0} ".format(symbols[p]).lower())
		print ""
		if c.lower() == "red" or c[:6].lower() == "priest":
			choice = 0
		elif c.lower() == "blue" or c[:6].lower() == "farmer":
			choice = 1
		elif c.lower() == "black" or c[:4].lower() == "king":
			choice = 2
		elif c.lower() == "green" or c[:6].lower() == "trader":
			choice = 3
		else: 
			print "Choose a valid leader"
			choice = False
		if choice != False:
			if choice in range(4) and cons[choice] == True:
				proceed = True
			elif choice in range(4) and cons[choice] == False:
				print "This type of leader is not in conflict"
	return choice
		
def prompt_tile_add(p,c, base):
	max_tiles = hands[p][c]
	print "Player " + str(p) + ":"
	print "Current conflict strength: {0}".format(base)
	print "How many tiles would you like to add?"
	display_hand(p)
	while True:
		print ""
		s = raw_input(" {0} ".format(symbols[p]).lower())
		print ""
		if s.isdigit() == False:
			print "Enter a valid number."
		elif int(s) > max_tiles:
			print "You do not have this many tiles."
		else:
			print "Player {0} adds {1} tiles for a total of {2}.".format( \
			p, s, base+int(s))
			print ""
			print ""
			hands[p][c] -= int(s)
			return int(s)

def assess_int_str(leader):
	leader_loc = get_leader_location()
	return len([q for q in adjacent_q(leader_loc[leader]) if grid[g] == "red"])

def internal_conflict(q,piece):
	assess_kingdoms()
	kdm = list([k for k in kingdoms if piece in k][0])
	if [L[:2] for L in kdm].count(piece[:2]) > 1:
		print ""
		print ""
		print "INTERNAL CONFLICT!!!"
		print ""
		pause = raw_input('...   ')
		base_att = len([rt for rt in adjacent_q(q) \
			if (grid[rt] == "red" or grid[rt] == "treasure")])
		kdm.remove(piece)
		leader_loc = get_leader_location()
		def_q = [leader_loc[L] for L in kdm if L[:2] == piece[:2]][0]
		base_def = len([rt for rt in adjacent_q(def_q) \
			if (grid[rt] == "red" or grid[rt] == "treasure")])
		att_s = base_att + prompt_tile_add(int(piece[2]), 0, base_att)
		def_s = base_def + prompt_tile_add(int(grid[def_q][2]), 0, base_def)
		if att_s > def_s:
			winner = int(piece[2])
			loser = (int(grid[def_q][2]), def_q)
			w_is_att = True
		else:
			winner = int(grid[def_q][2])
			loser = (int(piece[2]), q)
			w_is_att = False
		print "Player", winner, "has won the conflict!"
		place(loser[1], "empty")
		scores[winner][0] += 1
		win_points(winner, 0, 1, "the internal conflict")

def win_points(player, color, quantity, source):
	print "Player {0} scores {1} {2} point{3} from {4}.".format(player, \
		quantity, clist[color], "" if quantity == 1 else "s", source)
	scores[player][color] += quantity
	pause = raw_input('   ')

def check_treasure():
	corner_t = [ (2,2), (2,8), (16,2), (15,9) ]
	other_t = [ (6,3), (11,1), (14,5), (9,7), (6,10), (11,11) ]
	assess_kingdoms()
	klist = [K for K in kingdoms if \
		[grid[q][-8:] for q in kingdoms[K]['q']].count("treasure") > 1 and \
		[leader[0] for leader in K].count('g') == 1 ]
	if len(klist) > 0:
		for K in klist:
			print ""
			player = [int(L[2]) for L in K if L[0] == 'g'][0]
			num_tr = len([q for q in kingdoms[K]['q'] if grid[q][-8:] == \
					"treasure"])
			for i in range( num_tr - 1 ):
				treas_q = [q for q in kingdoms[K]['q'] if grid[q][-8:] == \
					"treasure"]
				if len(set(treas_q) & set(corner_t)) == 1:
					pick = [q for q in treas_q if q in corner_t][0]
				else:
					if human_or_comp[player] == "human":
						print "Player "+str(player)+", choose which treasure \
to take."
						print "(Choose the northwest space if the treausre is \
on a monument)"
						proceed = False
						while proceed == False:
							print ""
							raw_pick=raw_input(" {0} ".format(symbols[player]))
							print ""
							pick = grid_user_to_main(raw_pick)
							if pick == False:
								print "This is not a space on the grid."
							elif pick not in corner_t + other_t:
								print "There is no treasure on this space."
							elif pick in other_t and \
								len(set(treas_q) & set(corner_t)) > 0:
								print "You must pick a corner treasure."
							else:
								proceed = True
					else:
						pick = AI_treasure_pick()
				print "Player " + str(player) + " takes the treasure on " + \
					grid_main_to_user(pick) + "."
				treasure_count = len([q for q in corner_t+other_t if \
					grid[q][-8:] == "treasure"])
				if treasure_count > 3:
					print treasure_count - 1, "treasures left."
				elif treasure_count == 3:
					print "Only 2 treasures left.  Game ends after this turn."
				elif treasure_count == 2:
					print "Only 1 treasure left.  Game ends after this turn."
				if grid[pick] == "treasure":
					place(pick, "red")
				elif grid[pick][-8:] == "treasure":
					new_grid_id = grid[pick][:-8]
					place(pick, new_grid_id)
				else:
					print "ERROR 003"
				scores[player][4] += 1
				pause = raw_input('   ')
	treasure_count = len([q for q in corner_t+other_t if grid[q][-8:] == \
		"treasure"])
	if treasure_count < 2:
		treasure_out = True
	else: 
		treasure_out = False
	return treasure_out

def check_monument_build(Q, player):
	X,Y = Q
	color = grid[Q]
	available_m = [M for M in monuments if color in M]
	if len(available_m) > 0:
		NWcandidates = []
		if X != 1 and Y != 1: 
			NWcandidates.append((X-1,Y-1))
		if X != 16 and Y != 1:
			NWcandidates.append((X,Y-1))
		if X != 1 and Y != 11:
			NWcandidates.append((X-1,Y))
		if X != 16 and Y != 11:
			NWcandidates.append((X,Y))
		if color == "red":
			NWcand2 = [ (x,y) for (x,y) in NWcandidates if (grid[(x,y)] == \
			"red" or grid[(x,y)] == "treasure") and (grid[(x+1,y)] == "red" \
			or grid[(x+1,y)] == "treasure") and (grid[(x,y+1)] == "red" or \
			grid[(x,y+1)]== "treasure") and (grid[(x+1,y+1)]=="red" \
			or grid[(x+1,y+1)]=="treasure")]
		else:
			NWcand2 = [ (x,y) for (x,y) in NWcandidates if grid[(x,y)] == \
			grid[(x+1,y)] == grid[(x,y+1)] == grid[(x+1,y+1)] ]
		if len(NWcand2) > 0 and human_or_comp[player] == "human":
			print ""
			print "Player {0}, choose one of the options below.".format(player)
			print "[1] Take no action"
			print "[2] Place {0} monument".format(available_m[0])
			options = ['1','2']
			if len(available_m) > 1:
				print "[3] Place {0} monument".format(available_m[1])
				options.append('3')
			if len(available_m) == 3:
				print "[4] Place {0} monument".format(available_m[2])
				options.append('4')
			s = raw_input('  {0}  '.format(symbols[player]))
			while s not in options:
				print ""
				print "Type one of the numbers on the right listed above."
				print ""
				s = raw_input('  {0}  '.format(symbols[player]))
			choice = int(s)
			if choice > 1:
				mon = available_m[choice-2]
				monuments.remove(mon)
				if len(NWcand2) > 1:
					print ""
					print "Choose the spaces on which you would like to \
place the monument."
					options = ['1','2','3'] if len(NWcand2) == 3 else ['1','2']
					for i in range(len(NWcand2)):
						x,y = NWcand2[i]
						qq = [(x,y),(x+1,y),(x,y+1),(x+1,y+1)]
						uqq = [grid_main_to_user(q) for q in qq]
						print "[{0}] {1}, {2}, {3}, {4}".format(i+1, uqq[0], \
							uqq[1], uqq[2], uqq[3])
					print ""
					s = raw_input('  {0}  '.format(symbols[player]))
					while s not in options:
						print ""
						print "Type one of the numbers on the right listed above."
						print ""
						s = raw_input('  {0}  '.format(symbols[player]))
					NW_mon_dest = NWcand2[int(s)-1]
				else:
					NW_mon_dest = NWcand2[0]
				x,y = NW_mon_dest
				treas_in_mon = False
				for q in [(x,y),(x+1,y),(x,y+1),(x+1,y+1)]:
					if grid[q] == "treasure":
						grid[q] = mon + " treasure"
						treas_in_mon = True
					else:
						grid[q] = mon
				for c in clist:
					if c in mon and c != color:
						color2 = c
				paint_monument(NW_mon_dest, color, color2, treas_in_mon)
				check_temple_support()
		elif len(NWcand2) > 0 and human_or_comp[player] == "comp":
			AI_mon_build()

def check_temple_support():
	LL = get_leader_location()
	for leader in leaders:
		if LL[leader] != 0:
			adj_tiles = [grid[q] for q in adjacent_q(LL[leader])]
			if "red" not in adj_tiles and "treasure" not in adj_tiles:
				place(LL[leader],"empty")

def score_monuments(player):
	assess_kingdoms()
	rK = [k for k in kingdoms if 'rl'+str(player) in k]
	uK = [k for k in kingdoms if 'ul'+str(player) in k]
	aK = [k for k in kingdoms if 'al'+str(player) in k]
	gK = [k for k in kingdoms if 'gl'+str(player) in k]
	if rK != []:
		if "red - blue" in [grid[q] for q in kingdoms[rK[0]]['q']]:
			win_points(player, 0, 1, "the red-blue monument")
		if "red - black" in [grid[q] for q in kingdoms[rK[0]]['q']]:
			win_points(player, 0, 1, "the red-black monument")
		if "red - green" in [grid[q] for q in kingdoms[rK[0]]['q']]:
			win_points(player, 0, 1, "the red-green monument")
	if uK != []:
		if "red - blue" in [grid[q] for q in kingdoms[uK[0]]['q']]:
			win_points(player, 1, 1, "the red-blue monument")
		if "blue - black" in [grid[q] for q in kingdoms[uK[0]]['q']]:
			win_points(player, 1, 1, "the blue-black monument")
		if "blue - green" in [grid[q] for q in kingdoms[uK[0]]['q']]:
			win_points(player, 1, 1, "the blue-green monument")
	if aK != []:
		if "red - black" in [grid[q] for q in kingdoms[aK[0]]['q']]:
			win_points(player, 2, 1, "the red-black monument")
		if "blue - black" in [grid[q] for q in kingdoms[aK[0]]['q']]:
			win_points(player, 2, 1, "the blue-black monument")
		if "black - green" in [grid[q] for q in kingdoms[aK[0]]['q']]:
			win_points(player, 2, 1, "the black-green monument")
	if gK != []:
		if "red - green" in [grid[q] for q in kingdoms[gK[0]]['q']]:
			win_points(player, 3, 1, "the red-green monument")
		if "blue - green" in [grid[q] for q in kingdoms[gK[0]]['q']]:
			win_points(player, 3, 1, "the blue-green monument")
		if "black - green" in [grid[q] for q in kingdoms[gK[0]]['q']]:
			win_points(player, 3, 1, "the black-green monument")

def endgame_scoring():
	for i in range(20): print ""
	print "FINAL SCORING:"
	for p in range(1,5):
		print "Player {0}'s scores: red: {1}, blue: {2}, black: {3}, \
green: {4}, treasures: {5}.".format(p, scores[p][0], \
		scores[p][1], scores[p][2], scores[p][3], scores[p][4])
	print ""
	s = raw_input("   ")
	# calculate final scores:
	ordered_scores = {}
	for p in range(1,5):
		ordered_scores[p] = []
		remaining_scores = [list(tu) for tu in zip(range(4), scores[p][:4])]
		while remaining_scores != []:
			lowest_s = min([entry[1] for entry in remaining_scores])
			remove_list = []
			for color in remaining_scores:
				if color[1] == lowest_s:
					remove_list.append(color)
			for color in remove_list:
				remaining_scores.remove(color)
				ordered_scores[p].append(color)
	# [color, score] -> [c,s, treas added, total score]
	for p in range(1,5):
		for c in range(4):
			ordered_scores[p][c].append(0)
			ordered_scores[p][c].append(ordered_scores[p][c][1])
		for t in range(scores[p][4]):
			if ordered_scores[p][0][3] < ordered_scores[p][1][3]:
				# add treasure to first color
				ordered_scores[p][0][2] += 1
				ordered_scores[p][0][3] += 1
			elif ordered_scores[p][0][3] == ordered_scores[p][1][3]:
				if ordered_scores[p][1][3] < ordered_scores[p][2][3]:
					# add treasure to second color
					ordered_scores[p][1][2] += 1
					ordered_scores[p][1][3] += 1
				elif ordered_scores[p][1][3] == ordered_scores[p][2][3]:
					if ordered_scores[p][2][3] < ordered_scores[p][3][3]:
						# add treasure to third color
						ordered_scores[p][2][2] += 1
						ordered_scores[p][2][3] += 1
					elif ordered_scores[p][2][3] == ordered_scores[p][3][3]:
						# add treasure to fourth color
						ordered_scores[p][3][2] += 1
						ordered_scores[p][3][3] += 1
					else:
						print "ERROR 006"
				else:
					print "ERROR 005"
			else:
				print "ERROR 004"
	# rank players - this is a fifth entry in their ordered_scores lists
	rem_p = [1,2,3,4] # players with undetermined rank
	while rem_p != []:
		low1 = min([ordered_scores[p][0][3] for p in rem_p])
		pp1 = [p for p in rem_p if ordered_scores[p][0][3] == low1]
		if len(pp1) > 1:
			low2 = min([ordered_scores[p][1][3] for p in pp1])
			pp2 = [p for p in pp1 if ordered_scores[p][1][3] == low2]
			if len(pp2) > 1:
				low3 = min([ordered_scores[p][2][3] for p in pp2])
				pp3 = [p for p in pp2 if ordered_scores[p][2][3] == low3]
				if len(pp3) > 1:
					low4 = min([ordered_scores[p][3][3] for p in pp3])
					pp4 = [p for p in pp3 if ordered_scores[p][3][3] == low4]
					if len(pp4) > 1:
						ranking_p = max(pp4) # not in original rules: ultimate
					else:                    # ties are decided by highest 
						ranking_p = pp4[0]   # player number (i.e., latest 
				else:                        # first move)
					ranking_p = pp3[0]
			else:
				ranking_p = pp2[0]
		else:
			ranking_p = pp1[0]
		ordered_scores[ranking_p].append(len(rem_p))
		rem_p.remove(ranking_p)

	print "Place" + 3 * " " + "Player" + 3 * " " + "Lowest Score" + 11 * " " \
	+ "Second Lowest" + 10 * " " + "Third Lowest" + 11 * " " + "Fourth Lowest"

	for rank in range(4,0,-1):
		pause = raw_input(" "*80)
		P = [p for p in range(1,5) if ordered_scores[p][4] == rank][0]
		S = {1: "1st", 2: "2nd", 3: "3rd", 4:"4th"}[rank] + " " * 5 + \
		str(P) + "  " + symbols[P] * 3 + " "
		for color in range(4):
			s = NS(3,ordered_scores[P][color][1]) + " +" + \
			NS(3,ordered_scores[P][color][2]) + " =" + \
			NS(3,ordered_scores[P][color][3]) + \
			NS(8,("("+clist[ordered_scores[P][color][0]]+")"))
			S = S + s + "  "
		print S

def NS(length, x): # normalizes string to a certain length
	s = str(x)
	L = len(s)
	if length > L:
		return " " * (length - L) + s
	else:
		return s
	
def addrs(): # add random score - for testing
	for t in range(150):
		r1 = random()
		p = int(r1*4)+1
		r2 = random()
		c = int(r2*4)
		scores[p][c] += 1
	for t in range(8):
		r = random()
		p = int(r*4)+1
		scores[p][4] += 1

#

def AI_mother(p):
	print "AIAIAIAIAI"
	pass

def AI_choosing_conflicts():
	print "AIAIAIAIAI"
	pass

def AI_tile_add():
	print "AIAIAIAIAI"
	pass

def AI_treasure_pick():
	print "AIAIAIAIAI"
	pass

def AI_mon_build():
	print "AIAIAIAIAI"
	pass

#


###

##6## game structure






###

##T## test running
print """


"""



reset_variables_and_board()
print "   TIGRIS AND EUPHRATES"
pause = raw_input('   ')
initial_draw()

ok = True
p = 0
while ok != "stop":
	p = p % 4 + 1
	end_game = one_turn(p)
	if end_game == True:
		endgame_scoring()
		ok == "stop"
print """


... thank you for playing!
			"""
			





print """



"""
